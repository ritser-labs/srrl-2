{
  "experiment_info": {
    "date": "2025-08-04T03:54:34.836637",
    "model": "Qwen/Qwen2.5-3B-Instruct",
    "dataset": "MBPP",
    "training_problems": 60,
    "test_problems": 150,
    "improvements": "Numerical stability + proper prompts"
  },
  "grpo": {
    "method": "GRPO",
    "accuracy": 0.6266666666666667,
    "avg_reward": 0.6944444444444442,
    "correct_problems": 94,
    "total_problems": 150,
    "detailed_results": [
      {
        "task_id": 745,
        "generated_code": "def divisible_by_digits(startnum, endnum):\n    result = []\n    \n    for num in range(startnum, endnum + 1):\n        if num > 0:  # Skip negative numbers\n            str_num = str(num)\n            if all(int(digit) != 0 and num % int(digit) == 0 for digit in str_num):\n                result.append(num)\n                \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 746,
        "generated_code": "def sector_area(radius, angle):\n    # Check if the angle exceeds 360 degrees\n    if angle > 360:\n        return None\n    \n    # Calculate the area of the sector\n    area = (angle / 360) * 3.14159 * radius**2\n    \n    return area",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert sector_area(4,45)==6.283185307179586 -> 6.28318 (expected 6.283185307179586)",
          "assert sector_area(9,45)==31.808625617596654 -> 31.808598749999998 (expected 31.808625617596654)"
        ]
      },
      {
        "task_id": 747,
        "generated_code": "def lcs_of_three(X, Y, Z):\n    m, n, p = len(X), len(Y), len(Z)\n    \n    # Initialize the DP table with dimensions (m+1) x (n+1) x (p+1)\n    dp = [[[0 for _ in range(p + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, p + 1):\n                if X[i - 1] == Y[j - 1] == Z[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The result is stored in dp[m][n][p]\n    return dp[m][n][p]\n\n# Test case\nassert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 748,
        "generated_code": "def capital_words_spaces(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Process each word to insert spaces before those starting with a capital letter\n    processed_words = []\n    for word in words:\n        if word[0].isupper():\n            # Insert a space before the word\n            processed_word = f\"{word} \"\n        else:\n            processed_word = word\n        processed_words.append(processed_word)\n    \n    # Join the processed list of words back into a single string\n    result = ''.join(processed_words)\n    return result",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert capital_words_spaces(\"Python\") == 'Python' -> 'Python ' (expected 'Python')",
          "assert capital_words_spaces(\"PythonProgrammingExamples\") == 'Python Programming Examples' -> 'PythonProgrammingExamples ' (expected 'Python Programming Examples')",
          "assert capital_words_spaces(\"GetReadyToBeCodingFreak\") == 'Get Ready To Be Coding Freak' -> 'GetReadyToBeCodingFreak ' (expected 'Get Ready To Be Coding Freak')"
        ]
      },
      {
        "task_id": 749,
        "generated_code": "def sort_numeric_strings(strings):\n    # Convert each string in the list to an integer and store it in a new list\n    numeric_list = [int(s) for s in strings]\n    \n    # Sort the list of integers numerically\n    sorted_list = sorted(numeric_list)\n    \n    return sorted_list\n\n# Test the function with the provided test case\nassert sort_numeric_strings(['4', '12', '45', '7', '0', '100', '200', '-12', '-500']) == [-500, -12, 0, 4, 7, 12, 45, 100, 200]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 750,
        "generated_code": "def add_tuple(lst, tup):\n    # Convert the tuple to a list\n    lst_tup = list(tup)\n    \n    # Concatenate the list with the tuple's elements\n    result = lst + lst_tup\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 751,
        "generated_code": "def check_min_heap(arr):\n    n = len(arr)\n    \n    # Iterate over the range from 0 to n//2 - 1\n    for i in range(n // 2 - 1, -1, -1):\n        # Check the parent-child relationship\n        if arr[i] > arr[2 * i + 1]:\n            return False\n        if 2 * i + 2 < n and arr[i] > arr[2 * i + 2]:\n            return False\n    \n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 752,
        "generated_code": "def jacobsthal_num(n):\n    # Base cases\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the result list with base values\n    result = [0] * (n + 1)\n    result[0] = 0\n    result[1] = 1\n\n    # Fill the result array using the recurrence relation\n    for i in range(2, n + 1):\n        result[i] = result[i - 1] + 2 * result[i - 2]\n\n    return result[n]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 753,
        "generated_code": "def min_k(\n    tuples_list,\n    k\n):\n    # Sort the list of tuples based on the second element (value)\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Select the first k elements\n    min_k_records = sorted_tuples[:k]\n    \n    return min_k_records",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 754,
        "generated_code": "def extract_index_list(l1, l2, l3):\n    result = []\n    min_length = min(len(l1), len(l2), len(l3))\n\n    for i in range(min_length):\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 755,
        "generated_code": "def second_smallest(nums):\n    # Remove duplicates and sort the list\n    unique_sorted = sorted(set(nums))\n    \n    # Check if there are at least two elements left\n    if len(unique_sorted) < 2:\n        return None  # No valid second smallest number\n    \n    # Return the second smallest element\n    return unique_sorted[1]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 756,
        "generated_code": "def text_match_zero_one(text):\n    # Regex pattern: '^a(b*)' - Starts with 'a' followed by zero or more 'b's, and checks for at least one 'b'\n    pattern = r'^a(b*)$'\n    import re\n    if re.match(pattern, text):\n        return True\n    else:\n        return False",
        "execution_success": false,
        "reward": 0.5,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert text_match_zero_one(\"abbbba\")==True -> False (expected True)",
          "assert text_match_zero_one(\"dsabbbba\")==True -> False (expected True)",
          "assert text_match_zero_one(\"abaaa\")==True -> False (expected True)"
        ]
      },
      {
        "task_id": 757,
        "generated_code": "def reverse(s):\n    \"\"\"Helper function to get the reverse of a string.\"\"\"\n    return s[::-1]\n\ndef count_reverse_pairs(lst):\n    \"\"\"\n    Counts the number of pairs of reverse strings in the given list.\n    \n    Args:\n    lst (List[str]): The list of strings.\n    \n    Returns:\n    int: The number of reverse string pairs.\n    \"\"\"\n    # Dictionary to store strings and their counts\n    str_count = {}\n    reverse_str_count = {}\n    reverse_pair_count = 0\n    \n    for string in lst:\n        # Check if the reverse of the string is already in the dictionary\n        if reverse(string) in str_count:\n            reverse_pair_count += str_count[reverse(string)]\n        \n        # Update the count of the original string\n        if string in str_count:\n            str_count[string] += 1\n        else:\n            str_count[string] = 1\n        \n        # Update the count of the reversed string\n        if reverse(string) in reverse_str_count:\n            reverse_str_count[reverse(string)] += 1\n        else:\n            reverse_str_count[reverse(string)] = 1\n    \n    return reverse_pair_count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 758,
        "generated_code": "def unique_sublists(lst):\n    # <analysis>\n    # Initialize an empty dictionary to store the count of each sublist\n    sublists_count = {}\n    \n    # Iterate over all possible starting indices of sublists\n    for start_index in range(len(lst)):\n        # Iterate over all possible ending indices of sublists\n        for end_index in range(start_index, len(lst) + 1):\n            # Extract the sublist\n            sublist = tuple(lst[start_index:end_index])\n            \n            # If the sublist is already in the dictionary, increment its count\n            if sublist in sublists_count:\n                sublists_count[sublist] += 1\n            else:\n                # Otherwise, add the sublist to the dictionary with a count of 1\n                sublists_count[sublist] = 1\n                \n    # Return the dictionary containing the count of each sublist\n    return sublists_count\n    # </analysis>\n\n# Test the function\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpa_die7ys.py\", line 25, in <module>\n    assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpa_die7ys.py\", line 14, in unique_sublists\n    if sublist in sublists_count:\n       ^^^^^^^^^^^^^^^^^^^^^^^^^\nTypeError: unhashable type: 'list'\n",
        "failed_tests": []
      },
      {
        "task_id": 759,
        "generated_code": "def is_decimal(s):\n    before_dot, after_dot = s.split('.', 2)\n    if len(before_dot) > 0 and before_dot[0] in '1234567890' and len(after_dot) == 2:\n        try:\n            float(before_dot + '.' + after_dot)\n            return True\n        except ValueError:\n            return False\n    else:\n        return False",
        "execution_success": false,
        "reward": 0.8,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_decimal('1.1.11')==False -> ValueError: too many values to unpack (expected 2)"
        ]
      },
      {
        "task_id": 760,
        "generated_code": "def unique_Element(nums):\n    if not nums:  # Check if the list is empty\n        return True\n    return len(set(nums)) == 1  # Check if there's only one distinct element",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 762,
        "generated_code": "def check_monthnumber_number(month_num):\n    # List of months that have 30 days\n    thirty_day_months = [4, 6, 9, 11]\n    \n    # Check if the given month number is in the list\n    return month_num in thirty_day_months",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 763,
        "generated_code": "def find_min_diff(arr, n):\n    # Sort the array\n    arr.sort()\n    \n    min_diff = float('inf')  # Initialize with infinity\n    \n    for i in range(n-1):\n        diff = arr[i+1] - arr[i]\n        \n        if diff < min_diff:\n            min_diff = diff\n            \n    return min_diff",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_min_diff((1,5,3,19,18,25),6) == 1 -> AttributeError: 'tuple' object has no attribute 'sort'",
          "assert find_min_diff((4,3,2,6),4) == 1 -> AttributeError: 'tuple' object has no attribute 'sort'",
          "assert find_min_diff((30,5,20,9),4) == 4 -> AttributeError: 'tuple' object has no attribute 'sort'"
        ]
      },
      {
        "task_id": 764,
        "generated_code": "def number_ctr(s):\n    \"\"\"\n    Counts the number of digits in the given string s.\n    \"\"\"\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 765,
        "generated_code": "def is_polite(n):\n    \"\"\"\n    Finds the n-th polite number.\n    \n    Parameters:\n    n (int): The position of the polite number in the sequence.\n    \n    Returns:\n    int: The n-th polite number.\n    \"\"\"\n    # Check if n + 1 is a power of 2\n    if (n + 1 & (n + 1 - 1)) == 0:\n        return n + 1\n    else:\n        return n + 2",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_polite(7) == 11 -> 8 (expected 11)",
          "assert is_polite(4) == 7 -> 6 (expected 7)",
          "assert is_polite(9) == 13 -> 11 (expected 13)"
        ]
      },
      {
        "task_id": 766,
        "generated_code": "def pair_wise(lst):\n    \"\"\"\n    Given a list, returns a list of tuples containing consecutive pairs.\n    \n    :param lst: List of elements.\n    :return: List of tuples with consecutive pairs.\n    \"\"\"\n    # Generate pairs of consecutive items using list comprehension\n    pairs = [(lst[i], lst[i+1]) for i in range(len(lst) - 1)]\n    \n    return pairs\n\n\n# Test the function with the provided test case\nassert pair_wise([1,1,2,3,3,4,4,5]) == [(1, 1), (1, 2), (2, 3), (3, 3), (3, 4), (4, 4), (4, 5)]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 767,
        "generated_code": "def get_pairs_count(nums, sum_):\n    freq = {}\n    count = 0\n    \n    # First pass: populate the frequency dictionary\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Second pass: find complementary pairs\n    for num in nums:\n        comp = sum_ - num\n        if comp in freq:\n            count += freq[comp]\n    \n    # Adjust count if the same number was used as both parts of the pair\n    for num in set(nums):\n        if num * 2 == sum_:\n            count -= 1 if freq[num] > 1 else 0\n    \n    return count // 2",
        "execution_success": false,
        "reward": 0.75,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert get_pairs_count([1,1,1,1],2) == 6 -> 7 (expected 6)"
        ]
      },
      {
        "task_id": 769,
        "generated_code": "def Diff(list1, list2):\n    set1 = set(list1)\n    set2 = set(list2)\n    diff1 = sorted(list(set1 - set2))\n    diff2 = sorted(list(set2 - set1))\n    return diff1 + diff2",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15] -> [10, 15, 20, 30] (expected [10, 20, 30, 15])"
        ]
      },
      {
        "task_id": 770,
        "generated_code": "def odd_num_sum(n):\n    return n * (4 * n**2 - 1) * (2 * n**2 - 1) // 3",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert odd_num_sum(2) == 82 -> 70 (expected 82)",
          "assert odd_num_sum(3) == 707 -> 595 (expected 707)",
          "assert odd_num_sum(4) == 3108 -> 2604 (expected 3108)"
        ]
      },
      {
        "task_id": 771,
        "generated_code": "def check_expression(expression):\n    # Dictionary to hold the matching pairs of parentheses\n    matching_pairs = {')': '(', '}': '{', ']': '['}\n\n    # Initialize an empty stack\n    stack = []\n\n    # Iterate over each character in the expression\n    for char in expression:\n        # Push opening parentheses onto the stack\n        if char in matching_pairs.values():\n            stack.append(char)\n        # Pop the stack if a matching opening parenthesis is found\n        elif char in matching_pairs:\n            if not stack or stack.pop() != matching_pairs[char]:\n                return False\n        else:\n            # Ignore other characters\n            continue\n\n    # If the stack is empty, all parentheses were balanced\n    return len(stack) == 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 772,
        "generated_code": "def remove_length(s, k):\n    # Analysis:\n    # 1. Split the string into words using whitespace as the delimiter.\n    # 2. Filter out words that are not of length k.\n    # 3. Join the filtered list of words back into a single string.\n    \n    # Step 1: Split the string into words\n    words = s.split()\n    \n    # Step 2: Filter out words that are not of length k\n    filtered_words = [word for word in words if len(word) != k]\n    \n    # Step 3: Join the remaining words back into a single string\n    result = ' '.join(filtered_words)\n    \n    return result\n\n# Test the function\nassert remove_length('The person is most value tet', 3) == 'person is most value'",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 773,
        "generated_code": "def occurance_substring(string, substring):\n    positions = []\n    \n    for i in range(len(string)):\n        pos = string.find(substring, i)\n        if pos != -1:\n            positions.append((pos, len(substring)))\n    \n    if positions:\n        return positions[0]\n    else:\n        return None",
        "execution_success": false,
        "reward": 0.25,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert occurance_substring('python programming, python language','python')==('python', 0, 6) -> (0, 6) (expected ('python', 0, 6))",
          "assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18) -> (7, 11) (expected ('programming', 7, 18))",
          "assert occurance_substring('python programming,programming language','language')==('language', 31, 39) -> (31, 8) (expected ('language', 31, 39))"
        ]
      },
      {
        "task_id": 775,
        "generated_code": "def odd_position(lst):\n    # Analysis:\n    # Step 1: Filter odd numbers from the list\n    odd_numbers = [num for num in lst if num % 2 != 0]\n    \n    # Step 2: Check if each element at an odd index is even\n    for i in range(1, len(odd_numbers), 2):  # Start from 1 (first odd index) and increment by 2\n        if odd_numbers[i] % 2 == 0:\n            return False\n    \n    return True\n\n# Test the function\nassert odd_position([2,1,4,3,6,7,6,3]) == True",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert odd_position([1,2,3]) == False -> True (expected False)"
        ]
      },
      {
        "task_id": 776,
        "generated_code": "def count_vowels(s):\n    # Analysis\n    # Initialize the count of characters with vowel neighbors\n    count = 0\n    \n    # Helper function to check if a character is a vowel\n    def is_vowel(c):\n        return c.lower() in 'aeiou'\n    \n    # Iterate through the string, skipping the first and last characters\n    for i in range(1, len(s) - 1):\n        # Check if the current character has a vowel on either side\n        if is_vowel(s[i-1]) or is_vowel(s[i+1]):\n            count += 1\n    \n    return count\n\n# Test the function\nassert count_vowels('bestinstareels') == 7",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpcjtimo2x.py\", line 19, in <module>\n    assert count_vowels('bestinstareels') == 7\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 777,
        "generated_code": "def find_sum(lst):\n    # Analysis\n    # Create a set to store unique elements\n    unique_elements = set()\n    \n    # Use a set to keep track of seen elements\n    seen_elements = set()\n    \n    for num in lst:\n        if num not in seen_elements:\n            unique_elements.add(num)\n            seen_elements.add(num)\n        else:\n            unique_elements.discard(num)\n    \n    # Calculate the sum of the unique elements\n    return sum(unique_elements)\n\n# Test the function\nassert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmprzz98o68.py\", line 20, in <module>\n    assert find_sum([1, 2, 3, 1, 1, 4, 5, 6]) == 21\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 778,
        "generated_code": "def pack_consecutive_duplicates(nums):\n    i = j = 0\n    res = []\n    \n    while i < len(nums):\n        while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\n            i += 1\n        \n        res.append(nums[j:i + 1])\n        j = i + 1\n        i += 1\n    \n    return res",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])==[[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]] -> [[0], [0, 1, 2, 3, 4], [4, 5, 6], [6], [6, 7, 8, 9], [4], [4]] (expected [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]])",
          "assert pack_consecutive_duplicates([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10])==[[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]] -> [[10], [10], [15], [19], [18], [18], [17], [26], [26], [17, 18], [10]] (expected [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]])",
          "assert pack_consecutive_duplicates(['a', 'a', 'b', 'c', 'd', 'd'])==[['a', 'a'], ['b'], ['c'], ['d', 'd']] -> TypeError: unsupported operand type(s) for -: 'str' and 'int'"
        ]
      },
      {
        "task_id": 779,
        "generated_code": "def unique_sublists(lists):\n    sublists_count = {}\n    \n    for sublist in lists:\n        # Convert sublist to tuple\n        tuple_sublist = tuple(sublist)\n        \n        # Count occurrences of the tuple\n        if tuple_sublist in sublists_count:\n            sublists_count[tuple_sublist] += 1\n        else:\n            sublists_count[tuple_sublist] = 1\n    \n    return sublists_count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 780,
        "generated_code": "def find_combinations(tuples):\n    results = []\n    \n    # Generate all possible pairs of tuples\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            t1 = tuples[i]\n            t2 = tuples[j]\n            \n            # Calculate the sum of each pair\n            sum_t1_t2 = tuple(map(sum, zip(t1, t2)))\n            \n            # Check if the sum of the pair equals any other tuple\n            if sum_t1_t2 in tuples:\n                results.append((t1, sum_t1_t2))\n                \n    return results",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)] -> [] (expected [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)])",
          "assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)] -> [] (expected [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)])",
          "assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)] -> [] (expected [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)])"
        ]
      },
      {
        "task_id": 781,
        "generated_code": "def count_divisors(number):\n    count = 0\n    for i in range(1, number + 1):\n        if number % i == 0:\n            count += 1\n    \n    return count % 2 == 0",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpkjoabdne.py\", line 9\n    _val = assert count_divisors(10)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 782,
        "generated_code": "def odd_length_sum(arr):\n    n = len(arr)\n    return n * (n + 1) * (2 * n + 1) // 8",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert odd_length_sum([1,2,4]) == 14 -> 10 (expected 14)",
          "assert odd_length_sum([1,2,1,2]) == 15 -> 22 (expected 15)",
          "assert odd_length_sum([1,7]) == 8 -> 3 (expected 8)"
        ]
      },
      {
        "task_id": 783,
        "generated_code": "def rgb_to_hsv(rgb):\n    # Normalize RGB values to the range [0, 1]\n    r, g, b = rgb / 255.0\n    r_max, g_max, b_max = max(r, g, b), min(r, g, b), max(r, g, b)\n    \n    # Calculate Value (V)\n    V = r_max\n    \n    # Calculate Saturation (S)\n    if V != 0:\n        S = (V - g_max) / V\n    else:\n        S = 0\n    \n    # Calculate Hue (H)\n    if r == r_max:\n        H = 0\n    elif g == g_max:\n        H = 2\n    elif b == b_max:\n        H = 4\n        \n    # Convert to range [0, 100]\n    H /= 6\n    S *= 100.0\n    V *= 100.0\n    \n    return (H, S, V)",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert rgb_to_hsv(255, 255, 255)==(0, 0.0, 100.0) -> TypeError: rgb_to_hsv() takes 1 positional argument but 3 were given",
          "assert rgb_to_hsv(0, 215, 0)==(120.0, 100.0, 84.31372549019608) -> TypeError: rgb_to_hsv() takes 1 positional argument but 3 were given",
          "assert rgb_to_hsv(10, 215, 110)==(149.26829268292684, 95.34883720930233, 84.31372549019608) -> TypeError: rgb_to_hsv() takes 1 positional argument but 3 were given"
        ]
      },
      {
        "task_id": 784,
        "generated_code": "def mul_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n                \n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return \"No even or odd numbers found in the list\"",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 785,
        "generated_code": "def tuple_str_int(s):\n    # Check if the string starts and ends with parentheses\n    if s[0] != '(' or s[-1] != ')':\n        raise ValueError(\"Input string must start and end with parentheses\")\n    \n    # Remove the enclosing parentheses\n    inner_str = s[1:-1]\n    \n    # Split the inner string by commas\n    elements = inner_str.split(',')\n    \n    # Convert each element to an integer\n    int_elements = [int(element.strip()) for element in elements]\n    \n    # Return the resulting tuple\n    return tuple(int_elements)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 786,
        "generated_code": "def right_insertion(sorted_list, target):\n    \"\"\"\n    Finds the right insertion index for a given target in a sorted list.\n\n    Parameters:\n    sorted_list (list): A list of sorted integers.\n    target (int): The target integer to find the insertion index for.\n\n    Returns:\n    int: The index where the target should be inserted.\n    \"\"\"\n\n    left = 0\n    right = len(sorted_list) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n\n        if sorted_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return left\n\n# Test case\nassert right_insertion([1, 2, 4, 5], 6) == 4",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 787,
        "generated_code": "import re\n\ndef text_match_three(s):\n    # Use the re.match() function to find a match at the start of the string\n    return bool(re.match(r'ab{3}', s))\n\n# Test the function with the provided test case\nassert not text_match_three(\"ac\")",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmps1_b7ga8.py\", line 10\n    _val = assert not text_match_three(\"ac\")\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 788,
        "generated_code": "def new_tuple(strings_list, additional_string):\n    # Step 1: Convert the list of strings into a tuple\n    string_tuple = tuple(strings_list)\n    \n    # Step 2: Concatenate the tuple with the additional string\n    final_tuple = string_tuple + (additional_string,)\n    \n    return final_tuple\n\n# Test the function with the provided test case\nassert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best')",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 790,
        "generated_code": "def even_position(lst):\n    # Check if the length of the list is odd, return False immediately\n    if len(lst) % 2 != 0:\n        return False\n\n    # Initialize a counter for even indices\n    even_count = 0\n\n    for i in range(1, len(lst), 2):\n        # Count the elements following the current even-indexed element\n        count = 0\n        while i + count < len(lst) and lst[i + count] == lst[i]:\n            count += 1\n        # Check if the count is even\n        if count % 2 != 0:\n            return False\n        even_count += 1\n\n    return True",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert even_position([2,1,4]) == True -> False (expected True)"
        ]
      },
      {
        "task_id": 791,
        "generated_code": "def remove_nested(\n    # your implementation\n):\n    result = ()\n    for item in tup:\n        if isinstance(item, tuple):\n            result += remove_nested(item),\n        else:\n            result += item,\n    return result",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10) -> TypeError: remove_nested() takes 0 positional arguments but 1 was given",
          "assert remove_nested((2, 6, 8, (5, 7), 11)) == (2, 6, 8, 11) -> TypeError: remove_nested() takes 0 positional arguments but 1 was given",
          "assert remove_nested((3, 7, 9, (6, 8), 12)) == (3, 7, 9, 12) -> TypeError: remove_nested() takes 0 positional arguments but 1 was given",
          "assert remove_nested((3, 7, 9, (6, 8), (5,12), 12)) == (3, 7, 9, 12) -> TypeError: remove_nested() takes 0 positional arguments but 1 was given"
        ]
      },
      {
        "task_id": 792,
        "generated_code": "def count_list(list_of_lists):\n    list_count = 0\n    for element in list_of_lists:\n        if isinstance(element, list):\n            list_count += 1\n    return list_count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 793,
        "generated_code": "def last(arr, target):\n    \"\"\"\n    Finds the last position of an element in a sorted array.\n    \"\"\"\n    low, high = 0, len(arr) - 1\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        if arr[mid] == target:\n            result = mid\n            low = mid + 1  # Move low to mid+1 to find a potentially larger index\n        elif arr[mid] > target:\n            high = mid - 1\n        else:\n            low = mid + 1\n            \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 794,
        "generated_code": "import re\n\ndef text_starta_endb(text):\n    # Regex pattern to match strings starting with 'a' and ending with 'b'\n    pattern = r'^a.*b$'\n    \n    # Search for the pattern in the given text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmps5rwepe1.py\", line 13\n    _val = assert text_starta_endb(\"aabbbb\")\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 796,
        "generated_code": "def return_sum(dictionary):\n    total_sum = 0\n    for value in dictionary.values():\n        total_sum += value\n    return total_sum",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 797,
        "generated_code": "def sum_in_range(l, r):\n    \"\"\"\n    Returns the sum of all odd natural numbers between l and r inclusive.\n    \"\"\"\n    # Ensure l is less than or equal to r for correct iteration.\n    if l > r:\n        return 0\n    \n    total_sum = 0\n    # Loop from l to r (inclusive)\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            total_sum += num\n    return total_sum",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 798,
        "generated_code": "def _sum(arr):\n    # Initialize the sum to 0\n    total = 0\n    \n    # Iterate through each element in the array\n    for num in arr:\n        total += num\n    \n    # Return the computed sum\n    return total",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 799,
        "generated_code": "def left_rotate(num, d):\n    # Ensure d is within the range [0, 31]\n    d %= 32\n    \n    # Create masks for the leftmost and rightmost bits\n    left_mask = ((1 << d) - 1)\n    right_mask = (~left_mask) & ((1 << 32) - 1)\n    \n    # Rotate the number by shifting right part to left\n    rotated_right_part = num & right_mask\n    rotated_left_part = num >> d\n    \n    # Combine the rotated parts\n    return rotated_left_part | (rotated_right_part << d)",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert left_rotate(16,2) == 64 -> 68 (expected 64)",
          "assert left_rotate(10,2) == 40 -> 34 (expected 40)",
          "assert left_rotate(99,3) == 792 -> 780 (expected 792)",
          "assert left_rotate(99,3) == 792 -> 780 (expected 792)",
          "assert left_rotate(0b0001,3) == 0b1000 -> 0 (expected 8)",
          "assert left_rotate(0b0101,3) == 0b101000 -> 0 (expected 40)",
          "assert left_rotate(0b11101,3) == 0b11101000 -> 195 (expected 232)"
        ]
      },
      {
        "task_id": 800,
        "generated_code": "def remove_all_spaces(s):\n    return s.replace(\" \", \"\")",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 801,
        "generated_code": "def test_three_equal(a, b, c):\n    # Use a dictionary to count the occurrences of each integer\n    count_dict = {a: 0, b: 0, c: 0}\n\n    # Increment the count for each integer in the dictionary\n    for num in [a, b, c]:\n        count_dict[num] += 1\n\n    # Sum the counts to get the total number of equal numbers\n    total_count = sum(count_dict.values())\n\n    return total_count",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert test_three_equal(-1,-2,-3) == 0 -> 3 (expected 0)",
          "assert test_three_equal(1,2,2) == 2 -> 3 (expected 2)"
        ]
      },
      {
        "task_id": 802,
        "generated_code": "def count_rotation(arr):\n    \"\"\"\n    Counts the number of rotations required to make the given array sorted.\n    \n    :param arr: List[int] - The input array which needs to be rotated.\n    :return: int - Number of rotations needed.\n    \"\"\"\n    n = len(arr)\n    low, high = 0, n - 1\n    \n    while low <= high:\n        if arr[low] <= arr[high]:  # Array is already sorted\n            return 0\n        \n        mid = (low + high) // 2\n        \n        # Check if mid is the pivot\n        if mid < n - 1 and arr[mid] > arr[mid + 1]:\n            return mid + 1\n        \n        # Decide the direction to continue searching\n        if arr[low] <= arr[mid]:\n            low = mid + 1\n        else:\n            high = mid - 1\n            \n    return 0\n\n# Test the function\nassert count_rotation([3, 4, 5, 1, 2]) == 3",
        "execution_success": false,
        "reward": 0.4,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert count_rotation([3,2,1]) == 1 -> 2 (expected 1)",
          "assert count_rotation([4,5,1,2,3]) == 2 -> 0 (expected 2)",
          "assert count_rotation([1,3,2]) == 2 -> 0 (expected 2)"
        ]
      },
      {
        "task_id": 803,
        "generated_code": "import math\n\ndef is_perfect_square(n):\n    # Calculate the square root of the number\n    sqrt_n = math.sqrt(n)\n    \n    # Check if the square root is an integer\n    return sqrt_n.is_integer()",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpwc1lazja.py\", line 10\n    _val = assert not is_perfect_square(10)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 804,
        "generated_code": "def is_product_even(lst):\n    for num in lst:\n        if num % 2 == 0:\n            return True\n    return False",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmp8547uzm1.py\", line 7\n    _val = assert is_product_even([1,2,3])\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 805,
        "generated_code": "def max_sum_list(lists):\n    # Initialize variables to keep track of the maximum sum and the corresponding list\n    max_sum = float('-inf')\n    best_list = None\n    \n    # Iterate through each list in the list of lists\n    for sublist in lists:\n        current_sum = sum(sublist)  # Calculate the sum of the current list\n        \n        # Update the maximum sum and the corresponding list if the current sum is higher\n        if current_sum > max_sum:\n            max_sum = current_sum\n            best_list = sublist\n            \n    return best_list",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 806,
        "generated_code": "def max_run_uppercase(s):\n    max_count = 0\n    current_count = 0\n    \n    for char in s:\n        if char.isupper():\n            current_count += 1\n        else:\n            current_count = 0\n        \n        max_count = max(max_count, current_count)\n    \n    return max_count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 807,
        "generated_code": "def first_odd(numbers):\n    \"\"\"\n    Finds the first odd number in a given list of numbers.\n    \n    :param numbers: List of integers\n    :return: The first odd number in the list, or None if no odd number exists.\n    \"\"\"\n    first_odd_found = False\n    \n    for num in numbers:\n        if num % 2 != 0:\n            first_odd_found = True\n            return num\n    \n    if not first_odd_found:\n        return None\n\n# Test case\nassert first_odd([1, 3, 5]) == 1",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 808,
        "generated_code": "def check_K(tup, k):\n    for item in tup:\n        if item == k:\n            return True\n    return False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 809,
        "generated_code": "def check_smaller(tuple1, tuple2):\n    # Iterate through pairs of elements from both tuples\n    for elem1, elem2 in zip(tuple1, tuple2):\n        # Check if elem2 is not strictly smaller than elem1\n        if elem2 >= elem1:\n            return False\n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 554,
        "generated_code": "def Split(nums):\n    # <analysis>\n    # Initialize an empty list to store odd numbers\n    odd_numbers = []\n    \n    # Iterate through each number in the input list\n    for num in nums:\n        # Check if the number is odd\n        if num % 2 != 0:\n            # If odd, append it to the list of odd numbers\n            odd_numbers.append(num)\n    \n    # Return the list of odd numbers\n    return odd_numbers\n    # </analysis>\n\n# Test the function with the provided test case\nassert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 555,
        "generated_code": "def difference(n):\n    \"\"\"\n    Calculates the difference between the sum of cubes of the first n natural numbers\n    and the sum of the first n natural numbers.\n    \n    Parameters:\n    n (int): The number of terms\n    \n    Returns:\n    int: The difference\n    \"\"\"\n    # Calculate the sum of cubes\n    sum_of_cubes = (n * (n + 1) // 2) ** 2\n    \n    # Calculate the sum of the first n natural numbers\n    sum_of_numbers = n * (n + 1) // 2\n    \n    # Calculate the difference\n    difference = sum_of_cubes - sum_of_numbers\n    \n    return difference",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 556,
        "generated_code": "def find_Odd_Pair(nums, target):\n    # Counters to store the number of odd and even numbers\n    odd_count = 0\n    even_count = 0\n    \n    # Iterate through the list\n    for num in nums:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    \n    # Calculate the number of valid pairs\n    # A valid pair consists of one odd and one even number\n    return odd_count * even_count\n\n# Test the function with provided data point\nassert find_Odd_Pair([5, 4, 7, 2, 1], 5) == 6",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 557,
        "generated_code": "def toggle_string(s):\n    # Initialize an empty list to store toggled characters\n    toggled_chars = []\n    \n    # Iterate through each character in the input string\n    for char in s:\n        # Toggle the case of the character\n        if char.isupper():\n            toggled_chars.append(char.lower())\n        else:\n            toggled_chars.append(char.upper())\n    \n    # Join the list of characters into a string and return it\n    return ''.join(toggled_chars)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 558,
        "generated_code": "def digit_distance_nums(a, b):\n    # Convert integers to strings for easy digit access\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Calculate the sum of per-digit differences\n    return sum(abs(int(str_a[i]) - int(str_b[i])) for i in range(max(len(str_a), len(str_b))))",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 559,
        "generated_code": "def max_sub_array_sum(arr, n):\n    if not arr:\n        return 0\n    \n    global_max = current_max = arr[0]\n    \n    for i in range(1, n):\n        current_max = max(arr[i], current_max + arr[i])\n        global_max = max(global_max, current_max)\n        \n    return global_max",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 560,
        "generated_code": "def union_elements(tup1, tup2):\n    combined_set = set(tup1 + tup2)\n    combined_tuple = tuple(combined_set)\n    sorted_tuple = tuple(sorted(combined_tuple))\n    return sorted_tuple",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 562,
        "generated_code": "def Find_Max_Length(list_of_lists):\n    \"\"\"\n    Finds the length of the longest sublist within a given list of lists.\n\n    :param list_of_lists: A list containing sublists.\n    :return: The length of the longest sublist.\n    \"\"\"\n    # Check if the input is a list of lists\n    if not isinstance(list_of_lists, list) or not all(isinstance(sublist, list) for sublist in list_of_lists):\n        raise ValueError(\"Input must be a list of lists.\")\n\n    max_length = 0\n    for sublist in list_of_lists:\n        # Update max_length if the current sublist's length is greater\n        max_length = max(max_length, len(sublist))\n\n    return max_length\n\n# Test the function\nassert Find_Max_Length([[1], [1, 4], [5, 6, 7, 8]]) == 4",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 563,
        "generated_code": "def extract_values(s):\n    # Split the input string by commas\n    parts = s.split(',')\n    \n    # Initialize an empty list to hold the results\n    result = []\n    \n    # Iterate through each part and check if it starts with a double quote\n    for part in parts:\n        if part.startswith('\"') and part.endswith('\"'):\n            # Strip the leading and trailing double quotes and add to the result list\n            result.append(part[1:-1])\n    \n    return result",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert extract_values('\"Python\", \"PHP\", \"Java\"')==['Python', 'PHP', 'Java'] -> ['Python'] (expected ['Python', 'PHP', 'Java'])"
        ]
      },
      {
        "task_id": 564,
        "generated_code": "def count_Pairs(nums):\n    \"\"\"\n    Counts the number of unordered pairs in nums where both elements are unequal.\n    \"\"\"\n    # Analysis:\n    # 1. Create a set to get unique numbers.\n    # 2. Calculate the total possible pairs using combinations formula.\n    # 3. Subtract pairs involving repeated numbers.\n    \n    unique_nums = set(nums)\n    total_unique = len(unique_nums)\n    total_pairs = total_unique * (total_unique - 1) // 2\n    \n    # Check for repeated numbers\n    for num in nums:\n        if nums.count(num) > 1:\n            # Number appears more than once, so we need to subtract its combination count\n            total_pairs -= nums.count(num) * (nums.count(num) - 1) // 2\n    \n    return total_pairs\n\n# Test case\nassert count_Pairs([1,2,1]) == 2",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmprk062zo3.py\", line 23, in <module>\n    assert count_Pairs([1,2,1]) == 2\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 565,
        "generated_code": "def split(s):\n    return list(s)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 566,
        "generated_code": "def sum_digits(n):\n    # Initialize sum to 0\n    sum = 0\n    \n    # Loop until n becomes 0\n    while n > 0:\n        # Extract the last digit\n        digit = n % 10\n        # Add the digit to sum\n        sum += digit\n        # Remove the last digit\n        n //= 10\n    \n    return sum",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 567,
        "generated_code": "def issort_list(lst):\n    # Check if the list is empty or has one element\n    if len(lst) <= 1:\n        return True\n    \n    # Iterate through the list and check adjacent elements\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 568,
        "generated_code": "def empty_list(N):\n    \"\"\"\n    Creates a list of N empty dictionaries.\n    \"\"\"\n    result = []\n    for _ in range(N):\n        result.append({})\n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 569,
        "generated_code": "def sort_sublists(list_of_lists):\n    # Iterate through each sublist in the list\n    for i, sublist in enumerate(list_of_lists):\n        # Sort the sublist\n        list_of_lists[i] = sorted(sublist)\n    return list_of_lists",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 572,
        "generated_code": "def two_unique_nums(lists):\n    # Step 1: Flatten the list of lists\n    flattened_list = []\n    for sublist in lists:\n        flattened_list.extend(sublist)\n    \n    # Step 2: Remove duplicates using a set\n    unique_set = set(flattened_list)\n    \n    # Step 3: Convert back to a list\n    unique_list = list(unique_set)\n    \n    return unique_list",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5] -> TypeError: 'int' object is not iterable",
          "assert two_unique_nums([1,2,3,2,4,5]) == [1, 3, 4, 5] -> TypeError: 'int' object is not iterable",
          "assert two_unique_nums([1,2,3,4,5]) == [1, 2, 3, 4, 5] -> TypeError: 'int' object is not iterable"
        ]
      },
      {
        "task_id": 573,
        "generated_code": "import math\n\ndef unique_product(numbers):\n    # Step 1: Create a set to get unique numbers\n    unique_numbers = set(numbers)\n    \n    # Step 2: Convert the set back to a list\n    number_list = list(unique_numbers)\n    \n    # Step 3: Calculate the product of the unique numbers\n    product = math.prod(number_list) if number_list else 1\n    \n    return product\n\n# Test the function with the provided test case\nassert unique_product([10, 20, 30, 40, 20, 50, 60, 40]) == 720000000",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 574,
        "generated_code": "def surfacearea_cylinder(radius, height):\n    return 2 * math.pi * radius**2 + 2 * math.pi * radius * height",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert surfacearea_cylinder(10,5)==942.45 -> NameError: name 'math' is not defined",
          "assert surfacearea_cylinder(4,5)==226.18800000000002 -> NameError: name 'math' is not defined",
          "assert surfacearea_cylinder(4,10)==351.848 -> NameError: name 'math' is not defined"
        ]
      },
      {
        "task_id": 576,
        "generated_code": "def is_Sub_Array(main, sub):\n    for i in range(len(main) - len(sub) + 1):\n        k = i\n        for j in range(len(sub)):\n            if main[k] != sub[j]:\n                break\n            k += 1\n        else:\n            return True\n    return False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 577,
        "generated_code": "def last_Digit_Factorial(n):\n    # Direct computation for small values\n    if n <= 4:\n        return factorial_last_digit(n)\n    else:\n        return 0\n\ndef factorial_last_digit(n):\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0\n\n# Test case\nassert last_Digit_Factorial(4) == 4",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 578,
        "generated_code": "def interleave_lists(list1, list2, list3):\n    interleaved_list = []\n    for i in range(len(list1)):\n        interleaved_list.extend([list1[i], list2[i], list3[i]])\n    return interleaved_list",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 579,
        "generated_code": "def find_dissimilar(\n    tup1,\n    tup2\n):\n    set1 = set(tup1)\n    set2 = set(tup2)\n    \n    common_elements = set1 & set2\n    dissimilar_elements = set1 ^ set2\n    \n    return tuple(dissimilar_elements)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 580,
        "generated_code": "def extract_even(tpl):\n    def is_even(n):\n        return n % 2 == 0\n\n    result = []\n    \n    for item in tpl:\n        if isinstance(item, tuple):\n            # Recursively call extract_even on the nested tuple\n            sub_result = extract_even(item)\n            if sub_result:\n                result.append(sub_result)\n        elif is_even(item):\n            result.append(item)\n    \n    return tuple(result)\n\n# Test the function with the provided test case\nassert extract_even((4, 5, (7, 6, (2, 4)), 6, 8)) == (4, (6, (2, 4)), 6, 8)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 581,
        "generated_code": "def surface_Area(edge, height):\n    if edge <= 0 or height <= 0:\n        return \"Invalid input. Edge and height must be positive.\"\n    \n    base_area = edge ** 2\n    slant_height = (height ** 2 + (edge / 2) ** 2) ** 0.5\n    triangle_area = 0.5 * edge * slant_height\n    lateral_surface_area = 4 * triangle_area\n    \n    total_surface_area = base_area + lateral_surface_area\n    return total_surface_area",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert surface_Area(3,4) == 33 -> 34.63201123595259 (expected 33)",
          "assert surface_Area(4,5) == 56 -> 59.08131845707603 (expected 56)",
          "assert surface_Area(1,2) == 5 -> 5.123105625617661 (expected 5)"
        ]
      },
      {
        "task_id": 582,
        "generated_code": "def my_dict(dictionary):\n    return len(dictionary) == 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 583,
        "generated_code": "def catalan_number(n):\n    \"\"\"\n    Calculate the nth Catalan number using the direct formula.\n    \"\"\"\n    # Calculate the binomial coefficient (2n choose n)\n    binom_coeff = 1\n    for i in range(2*n, n, -1):\n        binom_coeff *= i\n    for i in range(1, n + 1):\n        binom_coeff //= i\n    \n    # Calculate the nth Catalan number\n    catalan = binom_coeff // (n + 1)\n    \n    return catalan",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 584,
        "generated_code": "def find_adverbs(sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Iterate over each word to find the first one ending with 'ly'\n    for i, word in enumerate(words):\n        if word.endswith('ly'):\n            # Return the word and its position (index + 1)\n            return f\"{i}-{i+1}: {word}\"\n    \n    # If no adverb ending with 'ly' is found, return None\n    return None",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_adverbs(\"Clearly, he has no excuse for such behavior.\") == '0-7: Clearly' -> None (expected '0-7: Clearly')",
          "assert find_adverbs(\"Please handle the situation carefuly\") == '28-36: carefuly' -> '4-5: carefuly' (expected '28-36: carefuly')",
          "assert find_adverbs(\"Complete the task quickly\") == '18-25: quickly' -> '3-4: quickly' (expected '18-25: quickly')"
        ]
      },
      {
        "task_id": 585,
        "generated_code": "def expensive_items(items, n):\n    # Extract relevant information and sort by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Slice the sorted list to get the top n items\n    result = sorted_items[:n]\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 586,
        "generated_code": "def split_Arr(arr, n):\n    # Ensure n is within bounds\n    if n >= len(arr) or n < 0:\n        return arr  # Return the original array if n is out of bounds\n    \n    # Find the index of the nth element\n    nth_index = n - 1 if n > 0 else n\n    \n    # Split the list\n    first_part = arr[:nth_index + 1]\n    second_part = arr[nth_index + 1:]\n    \n    # Reconcatenate the list\n    return second_part + first_part",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 587,
        "generated_code": "def list_tuple(lst):\n    return tuple(lst)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 588,
        "generated_code": "def big_diff(nums):\n    # Initialize variables to store the smallest and largest values\n    min_val = float('inf')\n    max_val = float('-inf')\n    \n    # Iterate through the list to find the minimum and maximum values\n    for num in nums:\n        if num < min_val:\n            min_val = num\n        if num > max_val:\n            max_val = num\n    \n    # Calculate the difference between the maximum and minimum values\n    return max_val - min_val",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 589,
        "generated_code": "def perfect_squares(start, end):\n    import math\n    \n    # Calculate the smallest integer whose square is >= start\n    min_square_root = math.ceil(math.sqrt(start))\n    \n    # Calculate the largest integer whose square is <= end\n    max_square_root = math.floor(math.sqrt(end))\n    \n    # Generate the list of perfect squares\n    perfect_squares_list = [i * i for i in range(min_square_root, max_square_root + 1)]\n    \n    return perfect_squares_list",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 590,
        "generated_code": "def polar_rect(r, theta):\n    \"\"\"\n    Convert polar coordinates (r, theta) to rectangular coordinates (x, y).\n    \n    Args:\n    r (float): The radius or magnitude of the polar coordinate.\n    theta (float): The angle in radians for the polar coordinate.\n    \n    Returns:\n    tuple: A tuple containing the rectangular coordinates (x, y).\n    \"\"\"\n    import math\n    \n    # Calculate x and y using the formulas\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    \n    # Return the result as a tuple\n    return ((x, y), complex(x, y))",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j)) -> ((-1.960930862590836, -2.2704074859237844), (-1.960930862590836-2.2704074859237844j)) (expected ((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j)))",
          "assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j)) -> ((3.0156090173732184, 2.6279463948751562), (3.0156090173732184+2.6279463948751562j)) (expected ((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j)))",
          "assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j)) -> ((-4.127450070773954, -14.420962378193352), (-4.127450070773954-14.420962378193352j)) (expected ((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j)))"
        ]
      },
      {
        "task_id": 591,
        "generated_code": "def swap_List(lst):\n    if not lst:  # check for empty list\n        return []\n    \n    n = len(lst)\n    lst[0], lst[n-1] = lst[n-1], lst[0]\n    return lst",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 592,
        "generated_code": "def sum_Of_product(n):\n    total_sum = 0\n    for k in range(n):\n        product = (n - k) * ((n - k) - 1) // 2\n        total_sum += product\n    return total_sum",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert sum_Of_product(3) == 15 -> 4 (expected 15)",
          "assert sum_Of_product(4) == 56 -> 10 (expected 56)",
          "assert sum_Of_product(1) == 1 -> 0 (expected 1)"
        ]
      },
      {
        "task_id": 593,
        "generated_code": "def removezero_ip(ip):\n    # Split the IP address into its four octets\n    parts = ip.split('.')\n    \n    # Process each octet and remove leading zeros\n    for i in range(len(parts)):\n        # Convert to integer, remove leading zeros, convert back to string\n        parts[i] = str(int(parts[i].lstrip('0')))\n    \n    # Join the processed octets back into a single string\n    return '.'.join(parts)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 594,
        "generated_code": "def diff_even_odd(lst):\n    # Initialize variables to store the first even and first odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and first odd numbers\n    for num in lst:\n        if num % 2 == 0:  # Check if the number is even\n            if first_even is None:\n                first_even = num\n            break  # Move to the next number after finding the first even\n    \n    if first_even is not None:  # Ensure first_even is not None\n        for num in lst[lst.index(first_even)+1:]:\n            if num % 2 != 0:  # Check if the number is odd\n                if first_odd is None:\n                    first_odd = num\n                break  # Move to the next number after finding the first odd\n    \n    # Calculate the difference if both first_even and first_odd are found\n    return first_even - first_odd if first_even is not None and first_odd is not None else None",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert diff_even_odd([1,2,3,4,5,6,7,8,9,10])==1 -> -1 (expected 1)",
          "assert diff_even_odd([1,5,7,9,10])==9 -> None (expected 9)"
        ]
      },
      {
        "task_id": 595,
        "generated_code": "def min_Swaps(binary_str1, binary_str2):\n    # Count the number of '1's in both binary strings\n    count1 = binary_str1.count('1')\n    count2 = binary_str2.count('1')\n    \n    # Determine if the number of '1's has the same parity\n    if (count1 % 2 == count2 % 2):\n        return 0\n    else:\n        return 1",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert min_Swaps(\"1101\",\"1110\") == 1 -> 0 (expected 1)",
          "assert min_Swaps(\"111\",\"000\") == \"Not Possible\" -> 1 (expected 'Not Possible')",
          "assert min_Swaps(\"111\",\"110\") == \"Not Possible\" -> 1 (expected 'Not Possible')"
        ]
      },
      {
        "task_id": 596,
        "generated_code": "import sys\n\ndef tuple_size(t):\n    # Use getsizeof to find the size in bytes\n    return sys.getsizeof(t)\n\n# Test the function with the provided test case\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 597,
        "generated_code": "def find_kth(arr1, arr2, k):\n    def find_kth_helper(arr1, arr2, k):\n        if not arr1:\n            return arr2[k]\n        if not arr2:\n            return arr1[k]\n        \n        mid1 = len(arr1) // 2\n        mid2 = len(arr2) // 2\n        \n        # Determine the middle elements of both halves\n        mid1_val = arr1[mid1] if mid1 else float('-inf')\n        mid2_val = arr2[mid2] if mid2 else float('inf')\n        \n        # Determine which half of the current partition contains the k-th element\n        if mid1 + mid2 >= k:\n            # The k-th element is in the left half of both arrays\n            return find_kth_helper(arr1[:mid1], arr2[:mid2], k)\n        else:\n            # The k-th element is in the right half of at least one array\n            return find_kth_helper(arr1[mid1:], arr2[mid2:], k - mid1 - mid2)\n\n    return find_kth_helper(arr1, arr2, k - 1)\n\n# Test case\nassert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpn3ipbwtb.py\", line 26, in <module>\n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn3ipbwtb.py\", line 23, in find_kth\n    return find_kth_helper(arr1, arr2, k - 1)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn3ipbwtb.py\", line 18, in find_kth_helper\n    return find_kth_helper(arr1[:mid1], arr2[:mid2], k)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn3ipbwtb.py\", line 21, in find_kth_helper\n    return find_kth_helper(arr1[mid1:], arr2[mid2:], k - mid1 - mid2)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn3ipbwtb.py\", line 21, in find_kth_helper\n    return find_kth_helper(arr1[mid1:], arr2[mid2:], k - mid1 - mid2)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpn3ipbwtb.py\", line 21, in find_kth_helper\n    return find_kth_helper(arr1[mid1:], arr2[mid2:], k - mid1 - mid2)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  [Previous line repeated 994 more times]\nRecursionError: maximum recursion depth exceeded\n",
        "failed_tests": []
      },
      {
        "task_id": 598,
        "generated_code": "def armstrong_number(n):\n    # Convert the number to a string to access each digit\n    num_str = str(n)\n    \n    # Calculate the number of digits\n    num_digits = len(num_str)\n    \n    # Initialize the sum to 0\n    sum_of_powers = 0\n    \n    # Iterate through each digit\n    for digit in num_str:\n        # Convert digit back to integer and raise it to the power of num_digits\n        sum_of_powers += int(digit) ** num_digits\n    \n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == n",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 599,
        "generated_code": "def sum_average(\n    n\n):\n    sum_n = n * (n + 1) // 2\n    avg_n = sum_n / n\n    return sum_n, avg_n",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 600,
        "generated_code": "def is_Even(n):\n    # Use the modulus operator to check if the number is divisible by 2\n    return n % 2 == 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 11,
        "generated_code": "def remove_Occ(s, char):\n    \"\"\"\n    Removes the first and last occurrences of a given character from the string.\n    \n    :param s: Input string\n    :param char: Character to remove\n    :return: Modified string with specified characters removed\n    \"\"\"\n    first_occurrence = None\n    last_occurrence = None\n    \n    # Iterate through the string to find the first and last occurrences\n    for i, c in enumerate(s):\n        if c == char:\n            if first_occurrence is None:\n                first_occurrence = i\n            else:\n                last_occurrence = i\n                break\n    \n    # If the character is not found, return the original string\n    if first_occurrence is None:\n        return s\n    \n    # Remove the first and last occurrences\n    modified_string = s[:first_occurrence] + s[last_occurrence+1:]\n    \n    return modified_string",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert remove_Occ(\"abcda\",\"a\") == \"bcd\" -> '' (expected 'bcd')",
          "assert remove_Occ(\"PHP\",\"P\") == \"H\" -> '' (expected 'H')"
        ]
      },
      {
        "task_id": 12,
        "generated_code": "def sort_matrix(matrix):\n    # Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Pair each row with its corresponding sum\n    row_sum_pairs = list(zip(matrix, row_sums))\n    \n    # Sort the pairs based on the sum of the rows\n    sorted_pairs = sorted(row_sum_pairs, key=lambda x: x[1])\n    \n    # Extract the sorted rows from the pairs\n    sorted_rows = [row for row, _ in sorted_pairs]\n    \n    return sorted_rows",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 14,
        "generated_code": "def find_Volume(a, b, c, h):\n    # Step 1: Calculate the semi-perimeter\n    s = (a + b + c) / 2\n    \n    # Step 2: Calculate the area using Heron's formula\n    A = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    \n    # Step 3: Calculate the volume\n    V = A * h\n    \n    return V\n\n# Test the function with the provided test case\nassert find_Volume(10, 8, 6, 10) == 240",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_Volume(10,8,6) == 240 -> TypeError: find_Volume() missing 1 required positional argument: 'h'",
          "assert find_Volume(3,2,2) == 6 -> TypeError: find_Volume() missing 1 required positional argument: 'h'",
          "assert find_Volume(1,2,1) == 1 -> TypeError: find_Volume() missing 1 required positional argument: 'h'"
        ]
      },
      {
        "task_id": 16,
        "generated_code": "def text_lowercase_underscore(text):\n    # Define the regex pattern\n    pattern = r'[a-z]+\\_[a-z]+'\n    \n    # Use re.fullmatch to check if the entire string matches the pattern\n    return bool(re.fullmatch(pattern, text))",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert text_lowercase_underscore(\"aab_cbbbc\")==(True) -> NameError: name 're' is not defined",
          "assert text_lowercase_underscore(\"aab_Abbbc\")==(False) -> NameError: name 're' is not defined",
          "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False) -> NameError: name 're' is not defined"
        ]
      },
      {
        "task_id": 17,
        "generated_code": "def square_perimeter(s):\n    \"\"\"\n    Calculate the perimeter of a square given its side length.\n\n    Parameters:\n    s (float): The side length of the square.\n\n    Returns:\n    float: The perimeter of the square.\n    \"\"\"\n    return 4 * s",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 18,
        "generated_code": "def remove_dirty_chars(dirty_str, clean_str):\n    # Initialize an empty string to store the result\n    result = ''\n    \n    # Iterate through each character in dirty_str\n    for char in dirty_str:\n        # Check if the character is not in clean_str\n        if char not in clean_str:\n            # Append the character to the result string\n            result += char\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 19,
        "generated_code": "def test_duplicate(arr):\n    \"\"\"\n    Determines if the given array contains any duplicate elements.\n    \"\"\"\n    return len(set(arr)) != len(arr)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 20,
        "generated_code": "def is_woodall(x):\n    if x < 0:\n        return False\n    for n in range(x + 1):  # Iterate over possible values of n\n        if (x + 1) % (2 ** n) == 0:\n            return True\n    return False",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_woodall(254) == False -> True (expected False)",
          "assert is_woodall(200) == False -> True (expected False)"
        ]
      },
      {
        "task_id": 56,
        "generated_code": "def check(num):\n    # Convert num to string and reverse it\n    reversed_num_str = str(num)[::-1]\n    # Convert reversed string back to integer\n    reversed_num = int(reversed_num_str)\n    # Check if num + 1 equals twice the reversed number\n    return num + 1 == 2 * reversed_num",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 57,
        "generated_code": "def find_Max_Num(digits):\n    # Separate non-zero and zero digits\n    non_zero_digits = [d for d in digits if d != 0]\n    zero_digits = [d for d in digits if d == 0]\n\n    # Sort non-zero digits in descending order\n    non_zero_digits.sort(reverse=True)\n\n    # Construct the result by concatenating non-zero digits and zero digits\n    result = ''.join(map(str, non_zero_digits)) + ''.join(map(str, zero_digits))\n\n    return int(result)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 58,
        "generated_code": "import math\n\ndef opposite_Signs(num1, num2):\n    return math.copysign(1, num1) != math.copysign(1, num2)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 59,
        "generated_code": "def is_octagonal(n):\n    \"\"\"\n    Returns the nth octagonal number using the formula O_n = n * (3n - 2).\n    \"\"\"\n    return n * (3 * n - 2)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 61,
        "generated_code": "def sum_of_digits(substring):\n    return sum(int(digit) for digit in substring)",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert count_Substrings('112112') == 6 -> NameError: name 'count_Substrings' is not defined",
          "assert count_Substrings('111') == 6 -> NameError: name 'count_Substrings' is not defined",
          "assert count_Substrings('1101112') == 12 -> NameError: name 'count_Substrings' is not defined"
        ]
      },
      {
        "task_id": 62,
        "generated_code": "def smallest_num(lst):\n    # Initialize smallest_num with a value greater than any element in the list\n    smallest_num = float('inf')\n    \n    # Iterate through each element in the list\n    for num in lst:\n        # Update smallest_num if the current element is smaller\n        if num < smallest_num:\n            smallest_num = num\n    \n    # Return the smallest number found\n    return smallest_num",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 63,
        "generated_code": "def max_difference(tuples_list):\n    max_diff = float('-inf')  # Initialize with negative infinity\n    \n    for tup in tuples_list:\n        for i in range(len(tup)):\n            for j in range(i + 1, len(tup)):\n                diff = abs(tup[i] - tup[j])  # Calculate absolute difference\n                if diff > max_diff:\n                    max_diff = diff  # Update max_diff if current difference is larger\n    \n    return max_diff\n\n# Test the function\nassert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 64,
        "generated_code": "def subject_marks(subjects_and_marks):\n    # Sort the list of tuples based on the second element (mark)\n    sorted_subjects = sorted(subjects_and_marks, key=lambda x: x[1])\n    return sorted_subjects",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 65,
        "generated_code": "def recursive_list_sum(lst):\n    if not isinstance(lst, list):  # Base case: lst is not a list\n        return lst\n    else:\n        total = 0\n        for item in lst:\n            total += recursive_list_sum(item)  # Recursively call the function\n        return total",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 66,
        "generated_code": "def pos_count(nums):\n    # Initialize the counter for positive numbers\n    count = 0\n    \n    # Iterate through each element in the list\n    for num in nums:\n        # Check if the current element is positive\n        if num > 0:\n            # Increment the counter\n            count += 1\n    \n    # Return the final count of positive numbers\n    return count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 67,
        "generated_code": "def bell_number(n):\n    if n == 0:\n        return 1\n    else:\n        bell = [1] * (n + 1)\n        for i in range(1, n + 1):\n            bell[i] = sum(bell[j] * math.comb(i - 1, j) for j in range(i))\n        return bell[n]\n\n# Testing the function\nassert bell_number(2) == 2",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpsu1908tl.py\", line 11, in <module>\n    assert bell_number(2) == 2\n           ^^^^^^^^^^^^^^\n  File \"/tmp/tmpsu1908tl.py\", line 7, in bell_number\n    bell[i] = sum(bell[j] * math.comb(i - 1, j) for j in range(i))\n              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/tmp/tmpsu1908tl.py\", line 7, in <genexpr>\n    bell[i] = sum(bell[j] * math.comb(i - 1, j) for j in range(i))\n                            ^^^^\nNameError: name 'math' is not defined\n",
        "failed_tests": []
      },
      {
        "task_id": 68,
        "generated_code": "def is_Monotonic(arr):\n    # Check if the array is non-decreasing\n    is_non_decreasing = all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n    \n    # Check if the array is non-increasing\n    is_non_increasing = all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1))\n    \n    # If either condition is true, the array is monotonic\n    return is_non_decreasing or is_non_increasing",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 69,
        "generated_code": "def is_sublist(lst, sub):\n    if len(sub) > len(lst):\n        return False\n\n    for i in range(len(lst) - len(sub) + 1):\n        if lst[i:i+len(sub)] == sub:\n            return True\n    return False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 70,
        "generated_code": "pass  # Placeholder for actual implementation\n    #",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert get_equal([(11, 22, 33), (44, 55, 66)]) == True -> NameError: name 'get_equal' is not defined",
          "assert get_equal([(1, 2, 3), (4, 5, 6, 7)]) == False -> NameError: name 'get_equal' is not defined",
          "assert get_equal([(1, 2), (3, 4)]) == True -> NameError: name 'get_equal' is not defined"
        ]
      },
      {
        "task_id": 71,
        "generated_code": "def comb_sort(lst):\n    # Convert the input to a Python list\n    lst = list(lst)\n    \n    # Initial gap size is the length of the list\n    gap = len(lst)\n    shrink_factor = 1.3\n    \n    # Continue sorting until gap is 1\n    while gap > 1:\n        # Decrease the gap by the shrink factor\n        gap = int(gap / shrink_factor)\n        \n        # Perform a bubble sort-like comparison and swap\n        for i in range(len(lst) - gap):\n            if lst[i] > lst[i + gap]:\n                # Swap the elements\n                lst[i], lst[i + gap] = lst[i + gap], lst[i]\n                \n    return lst",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 72,
        "generated_code": "def dif_Square(n):\n    # Check if n is odd or a multiple of 4\n    return n % 4 != 3",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert dif_Square(10) == False -> True (expected False)",
          "assert dif_Square(15) == True -> False (expected True)"
        ]
      },
      {
        "task_id": 74,
        "generated_code": "def is_samepatterns(patterns1, patterns2):\n    # Initialize sets to keep track of unique elements\n    set1 = set()\n    set2 = set()\n\n    # Compare each pair of elements\n    for p1, p2 in zip(patterns1, patterns2):\n        # Convert strings to lowercase for case-insensitive comparison\n        p1_lower = p1.lower()\n        p2_lower = p2.lower()\n\n        # Check if the current elements match\n        if p1_lower != p2_lower:\n            return False\n\n        # Ensure each element maps uniquely\n        if p1_lower in set1 and p1_lower != set1.pop():\n            return False\n        if p2_lower in set2 and p2_lower != set2.pop():\n            return False\n\n        # Add elements to their respective sets\n        set1.add(p1_lower)\n        set2.add(p2_lower)\n\n    # Return True if no mismatches were found\n    return True",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_samepatterns([\"red\",\"green\",\"green\"], [\"a\", \"b\", \"b\"])==True -> False (expected True)"
        ]
      },
      {
        "task_id": 75,
        "generated_code": "def find_tuples(tuples_list, k):\n    result = []\n    \n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 77,
        "generated_code": "def is_Diff(n):\n    \"\"\"\n    Check if a given number is divisible by 11 using the divisibility rule.\n    \n    Args:\n    n (int): The number to check.\n    \n    Returns:\n    bool: True if the number is divisible by 11, False otherwise.\n    \"\"\"\n    original_number = n\n    positive_flag = True\n    \n    # Handle negative numbers\n    if n < 0:\n        positive_flag = False\n        n = abs(n)\n    \n    # Extract digits and compute sums for odd and even positions\n    sum_odd = 0\n    sum_even = 0\n    while n > 0:\n        digit = n % 10\n        if (n // 10) % 2 == 0:  # Even position\n            sum_even += digit\n        else:  # Odd position\n            sum_odd += digit\n        n //= 10\n    \n    # Check if the difference is divisible by 11\n    if (sum_odd - sum_even) % 11 == 0:\n        return True\n    else:\n        return False\n\n# Test case\nassert is_Diff(12345) == False",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_Diff(1212112) == True -> False (expected True)"
        ]
      },
      {
        "task_id": 79,
        "generated_code": "def word_len(word):\n    \"\"\"\n    Checks if the length of the input word is odd.\n    \n    Parameters:\n    - word: The word to check.\n    \n    Returns:\n    - True if the length of the word is odd, False otherwise.\n    \"\"\"\n    # Extracting the length of the word\n    length = len(word)\n    \n    # Checking if the length is odd\n    return length % 2 != 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 80,
        "generated_code": "def tetrahedral_number(n):\n    # Using the formula for the nth tetrahedral number\n    return n * (n + 1) * (n + 2) // 6",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 82,
        "generated_code": "def volume_sphere(radius):\n    \"\"\"Calculate the volume of a sphere given its radius.\"\"\"\n    pi = 3.14159\n    return (4/3) * pi * radius**3",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpoy9d1egf.py\", line 7\n    _val = assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 83,
        "generated_code": "def get_Char(s):\n    # Analysis\n    # Initialize sum to 0\n    char_sum = 0\n    \n    # Iterate over each character in the string\n    for char in s:\n        # Convert character to its ASCII value and add to sum\n        char_sum += ord(char)\n    \n    # Apply modulo 26 to ensure the result is within the range [0, 25]\n    char_sum %= 26\n    \n    # Map the integer result to the corresponding letter in the alphabet\n    return chr(char_sum + ord('a'))\n\n# Test the function\nassert get_Char(\"abc\") == \"f\"",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpe7fnt7j2.py\", line 18, in <module>\n    assert get_Char(\"abc\") == \"f\"\n           ^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 84,
        "generated_code": "def sequence(n):\n    def newman_conway_helper(k, memo):\n        if k == 0 or k == 1:\n            return memo[k]\n        if memo[k] != 0:\n            return memo[k]\n        \n        memo[k] = newman_conway_helper(newman_conway_helper(k - 1, memo), memo) + newman_conway_helper(k - newman_conway_helper(k - 1, memo), memo)\n        return memo[k]\n\n    memo = [0] * (n + 1)\n    memo[0], memo[1] = 2, 1\n    \n    for i in range(2, n + 1):\n        memo[i] = newman_conway_helper(i, memo)\n    \n    return memo[n]\n\n# Test the function\nassert sequence(10) == 6",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpqfjrzv13.py\", line 20, in <module>\n    assert sequence(10) == 6\n           ^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 85,
        "generated_code": "def surfacearea_sphere(r):\n    # Calculate the surface area using the formula 4*pi*r^2\n    A = 4 * math.pi * r**2\n    return A",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpzqhei_be.py\", line 7\n    _val = assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 86,
        "generated_code": "def centered_hexagonal_number(n):\n        return 3 * n * (n - 1) + 1",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 87,
        "generated_code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, { \"G\": \"Green\", \"W\": \"White\" },{\"L\":\"lavender\",\"B\":\"Blue\"})=={'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'} -> {'R': 'Red', 'B': 'Blue', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'L': 'lavender'} (expected {'W': 'White', 'P': 'Pink', 'B': 'Black', 'R': 'Red', 'G': 'Green', 'L': 'lavender'})",
          "assert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" },{\"L\":\"lavender\",\"B\":\"Blue\"},{ \"G\": \"Green\", \"W\": \"White\" })=={'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'} -> {'R': 'Red', 'B': 'Blue', 'P': 'Pink', 'L': 'lavender', 'G': 'Green', 'W': 'White'} (expected {'B': 'Black', 'P': 'Pink', 'R': 'Red', 'G': 'Green', 'L': 'lavender', 'W': 'White'})"
        ]
      },
      {
        "task_id": 88,
        "generated_code": "def freq_count(lst):\n    freq_dict = {}\n    \n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n            \n    return freq_dict",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 89,
        "generated_code": "def closest_num(n):\n    if n > 0:\n        return n - 1\n    elif n == 0:\n        return n\n    else:  # n < 0\n        return n + 1",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 90,
        "generated_code": "def len_log(words):\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 91,
        "generated_code": "def find_substring(string_list, substring):\n    for string in string_list:\n        if substring in string:\n            return True\n    return False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 92,
        "generated_code": "def is_undulating(num):\n    num_str = str(num)\n    n = len(num_str)\n    \n    # Check if the length of the number is even\n    if n % 2 != 0:\n        return False\n    \n    for i in range(0, n-1, 2):\n        # Compare the current digit with the next one\n        if num_str[i] != num_str[i+1]:\n            return False\n    \n    return True",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_undulating(1212121) == True -> False (expected True)",
          "assert is_undulating(121) == True -> False (expected True)"
        ]
      },
      {
        "task_id": 93,
        "generated_code": "def power(a, b):\n    \"\"\"\n    Calculate a raised to the power of b.\n\n    Parameters:\n    a (int): The base number.\n    b (int): The exponent.\n\n    Returns:\n    int: The result of a^b.\n    \"\"\"\n    return a ** b\n\n# Test the function with the provided test case\nassert power(3, 4) == 81",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 94,
        "generated_code": "def index_minimum(tuples_list):\n    # Initialize variables to store the minimum second value and the corresponding first value\n    min_second_value = float('inf')\n    result_first_value = None\n    \n    for tup in tuples_list:\n        # Check if the current tuple's second value is smaller than the recorded minimum\n        if tup[1] < min_second_value:\n            min_second_value = tup[1]\n            result_first_value = tup[0]\n    \n    return result_first_value",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 95,
        "generated_code": "def Find_Min_Length(lists):\n    # Initialize min_length with a very large value\n    min_length = float('inf')\n    \n    # Iterate through each sublist in the list of lists\n    for sublist in lists:\n        # Update min_length if the current sublist's length is smaller\n        min_length = min(min_length, len(sublist))\n    \n    return min_length",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 96,
        "generated_code": "def divisor(n):\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 97,
        "generated_code": "def frequency_lists(nested_list):\n    def flatten(lst):\n        for el in lst:\n            if isinstance(el, list):\n                yield from flatten(el)\n            else:\n                yield el\n    \n    flat_list = list(flatten(nested_list))\n    \n    freq_dict = {}\n    for item in flat_list:\n        freq_dict[item] = freq_dict.get(item, 0) + 1\n    \n    return freq_dict\n\n# Test the function with provided data point\nassert frequency_lists([[1, 2, 3, 2], [4, 5, 6, 2], [7, 8, 9, 5]]) == {1: 1, 2: 3, 3: 1, 4: 1, 5: 2, 6: 1, 7: 1, 8: 1, 9: 1}",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 98,
        "generated_code": "def isclose(\n    nums: tuple\n) -> float:\n    product = 1\n    count = 0\n    \n    for num in nums:\n        product *= num\n        count += 1\n        \n    return product / count",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpnl4qfxfa.py\", line 14\n    _val = assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 99,
        "generated_code": "def decimal_to_binary(n):\n    binary = ''\n    while n > 0:\n        remainder = str(n % 2)\n        binary = remainder + binary\n        n = n // 2\n    return binary",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      }
    ]
  },
  "srrl": {
    "method": "SRRL",
    "accuracy": 0.6666666666666666,
    "avg_reward": 0.7101111111111107,
    "correct_problems": 100,
    "total_problems": 150,
    "detailed_results": [
      {
        "task_id": 745,
        "generated_code": "def divisible_by_digits(startnum, endnum):\n    def is_divisible_by_digits(n):\n        for digit in str(n):\n            if int(digit) == 0 or n % int(digit) != 0:\n                return False\n        return True\n\n    result = []\n    for num in range(startnum, endnum + 1):\n        if is_divisible_by_digits(num):\n            result.append(num)\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 746,
        "generated_code": "def sector_area(radius, angle):\n    # Check if the angle is within the valid range (0 to 360)\n    if angle > 360:\n        return None\n    \n    # Calculate the area of the sector\n    area = (angle / 360) * 3.14159 * radius ** 2\n    return area",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert sector_area(4,45)==6.283185307179586 -> 6.28318 (expected 6.283185307179586)",
          "assert sector_area(9,45)==31.808625617596654 -> 31.808598749999998 (expected 31.808625617596654)"
        ]
      },
      {
        "task_id": 747,
        "generated_code": "def lcs_of_three(str1, str2, str3):\n    m, n, o = len(str1), len(str2), len(str3)\n    \n    # Initialize the dp table with zeros\n    dp = [[[0 for _ in range(o + 1)] for _ in range(n + 1)] for _ in range(m + 1)]\n    \n    # Fill the dp table\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            for k in range(1, o + 1):\n                if str1[i-1] == str2[j-1] == str3[k-1]:\n                    dp[i][j][k] = dp[i-1][j-1][k-1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    \n    return dp[m][n][o]\n\n# Test case\nassert lcs_of_three('AGGT12', '12TXAYB', '12XBA') == 2",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 748,
        "generated_code": "def capital_words_spaces(s):\n    # Split the string into words\n    words = s.split()\n    \n    # Initialize the result list to hold processed words\n    result = []\n    \n    # Process each word\n    for i, word in enumerate(words):\n        # Check if the current word starts with a capital letter\n        if i == 0 or not words[i-1].isupper():\n            result.append(word)\n        else:\n            result.append(' ' + word)\n    \n    # Join the words with spaces and return the result\n    return ''.join(result)",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert capital_words_spaces(\"PythonProgrammingExamples\") == 'Python Programming Examples' -> 'PythonProgrammingExamples' (expected 'Python Programming Examples')",
          "assert capital_words_spaces(\"GetReadyToBeCodingFreak\") == 'Get Ready To Be Coding Freak' -> 'GetReadyToBeCodingFreak' (expected 'Get Ready To Be Coding Freak')"
        ]
      },
      {
        "task_id": 749,
        "generated_code": "def sort_numeric_strings(strings):\n    # Convert each string in the list to an integer\n    int_list = [int(s) for s in strings]\n    \n    # Sort the list of integers\n    sorted_list = sorted(int_list)\n    \n    # Convert the sorted integers back to strings\n    sorted_strings = [str(num) for num in sorted_list]\n    \n    return sorted_strings",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert sort_numeric_strings( ['4','12','45','7','0','100','200','-12','-500'])==[-500, -12, 0, 4, 7, 12, 45, 100, 200] -> ['-500', '-12', '0', '4', '7', '12', '45', '100', '200'] (expected [-500, -12, 0, 4, 7, 12, 45, 100, 200])",
          "assert sort_numeric_strings(['2','3','8','4','7','9','8','2','6','5','1','6','1','2','3','4','6','9','1','2'])==[1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9] -> ['1', '1', '1', '2', '2', '2', '2', '3', '3', '4', '4', '5', '6', '6', '6', '7', '8', '8', '9', '9'] (expected [1, 1, 1, 2, 2, 2, 2, 3, 3, 4, 4, 5, 6, 6, 6, 7, 8, 8, 9, 9])",
          "assert sort_numeric_strings(['1','3','5','7','1', '3','13', '15', '17','5', '7 ','9','1', '11'])==[1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17] -> ['1', '1', '1', '3', '3', '5', '5', '7', '7', '9', '11', '13', '15', '17'] (expected [1, 1, 1, 3, 3, 5, 5, 7, 7, 9, 11, 13, 15, 17])"
        ]
      },
      {
        "task_id": 750,
        "generated_code": "def add_tuple(lst, tup):\n    # Iterate through each element in the tuple and append it to the list\n    for element in tup:\n        lst.append(element)\n    return lst",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 751,
        "generated_code": "def check_min_heap(arr):\n    n = len(arr)\n    \n    # Traverse the array starting from the last non-leaf node\n    for i in range(n // 2 - 1, -1, -1):\n        # Check the heap property\n        if arr[i] > arr[2 * i + 1]:\n            return False\n    \n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 752,
        "generated_code": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Initialize the first two Jacobsthal numbers\n    a, b = 0, 1\n    \n    # Compute the Jacobsthal numbers up to n\n    for _ in range(2, n + 1):\n        a, b = b, a + 2 * b\n    \n    return b",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert jacobsthal_num(5) == 11 -> 29 (expected 11)",
          "assert jacobsthal_num(2) == 1 -> 2 (expected 1)",
          "assert jacobsthal_num(4) == 5 -> 12 (expected 5)",
          "assert jacobsthal_num(13) == 2731 -> 33461 (expected 2731)"
        ]
      },
      {
        "task_id": 753,
        "generated_code": "def min_k(tuples_list, k):\n    # Sort the list of tuples based on the second element in each tuple\n    sorted_tuples = sorted(tuples_list, key=lambda x: x[1])\n    \n    # Select the first k elements from the sorted list\n    result = sorted_tuples[:k]\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 754,
        "generated_code": "def extract_index_list(l1, l2, l3):\n    result = []\n    \n    # Find the minimum length among the lists\n    min_length = min(len(l1), len(l2), len(l3))\n    \n    for i in range(min_length):\n        # Check if the elements at index i in all three lists are the same\n        if l1[i] == l2[i] == l3[i]:\n            result.append(l1[i])\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 755,
        "generated_code": "def second_smallest(lst):\n    # Remove duplicates and convert to a set for uniqueness\n    unique_numbers = set(lst)\n    \n    # Convert back to a list to maintain order and remove duplicates\n    sorted_unique_numbers = sorted(list(unique_numbers))\n    \n    # Check if there are at least two unique numbers\n    if len(sorted_unique_numbers) < 2:\n        return None\n    \n    # Return the second smallest number\n    return sorted_unique_numbers[1]\n\n# Test the function\nassert second_smallest([1, 2, -8, -2, 0, -2]) == -2",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 756,
        "generated_code": "import re\n\ndef text_match_zero_one(text):\n    # Regular expression to match 'a' followed by one or more 'b's\n    pattern = 'ab+'\n    \n    # Search for the pattern in the given text\n    if re.search(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function\nassert text_match_zero_one(\"ac\") == False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 757,
        "generated_code": "def count_reverse_pairs(strings):\n    # Create a set for efficient lookup\n    string_set = set(strings)\n    \n    count = 0\n    \n    for s in strings:\n        reversed_s = s[::-1]\n        \n        # Check if the reverse exists in the set\n        if reversed_s in string_set:\n            # Increment count for unique pairs\n            count += 1\n            \n    # Since each pair is counted twice (once for each element), divide by 2\n    return count // 2",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 758,
        "generated_code": "def unique_sublists(lst):\n    # Initialize an empty dictionary to store the counts\n    counts = {}\n    \n    # Iterate through each sublist in the input list\n    for sublist in lst:\n        # Convert the sublist to a tuple\n        subtuple = tuple(sublist)\n        \n        # Update the count for this tuple in the dictionary\n        if subtuple in counts:\n            counts[subtuple] += 1\n        else:\n            counts[subtuple] = 1\n    \n    return counts",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 759,
        "generated_code": "def is_decimal(s):\n    # Remove leading and trailing whitespaces\n    s = s.strip()\n    \n    # Check for the presence of exactly one dot\n    if '.' not in s and len(s) > 0:\n        return False\n    \n    if '.' in s:\n        parts = s.split('.')\n        \n        # Check if there are exactly two parts\n        if len(parts) != 2:\n            return False\n        \n        # Check if the part before the dot is an integer\n        if not parts[0].isdigit():\n            return False\n        \n        # Check if the part after the dot has exactly two digits\n        if not parts[1].isdigit() or len(parts[1]) != 2:\n            return False\n    \n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 760,
        "generated_code": "def unique_Element(nums):\n    if len(nums) == 1:\n        return True\n    else:\n        first_element = nums[0]\n        for num in nums[1:]:\n            if num != first_element:\n                return False\n        return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 762,
        "generated_code": "def check_monthnumber_number(month):\n        # Check if the month number is 4, 6, 9, or 11\n        return month in [4, 6, 9, 11]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 763,
        "generated_code": "def find_min_diff(arr, n):\n    # Sort the array\n    arr.sort()\n    \n    min_diff = float('inf')  # Initialize with infinity\n    \n    # Iterate through the array and find the minimum difference\n    for i in range(n - 1):\n        min_diff = min(min_diff, arr[i + 1] - arr[i])\n        \n    return min_diff",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_min_diff((1,5,3,19,18,25),6) == 1 -> AttributeError: 'tuple' object has no attribute 'sort'",
          "assert find_min_diff((4,3,2,6),4) == 1 -> AttributeError: 'tuple' object has no attribute 'sort'",
          "assert find_min_diff((30,5,20,9),4) == 4 -> AttributeError: 'tuple' object has no attribute 'sort'"
        ]
      },
      {
        "task_id": 764,
        "generated_code": "def number_ctr(s):\n    ctr = 0  # Initialize counter\n    for char in s:  # Iterate through each character\n        if char.isdigit():  # Check if character is a digit\n            ctr += 1  # Increment counter if it is a digit\n    return ctr  # Return the total count of digits",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 765,
        "generated_code": "def is_polite(n):\n    \"\"\"\n    Helper function to check if a number is polite.\n    \"\"\"\n    # Check if n can be expressed as a sum of consecutive numbers\n    for i in range(1, int((n ** 0.5) + 1)):\n        if (i * (2 * i - 1)) > n:\n            break\n        if (n - (i * (2 * i - 1))) % (2 * i) == 0:\n            return True\n    return False\n\ndef nth_polite_number(n):\n    \"\"\"\n    Find the nth polite number.\n    \"\"\"\n    count = 0\n    num = 1\n    \n    while count < n:\n        if is_polite(num):\n            count += 1\n        num += 1\n    \n    return num - 1",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_polite(7) == 11 -> True (expected 11)",
          "assert is_polite(4) == 7 -> False (expected 7)",
          "assert is_polite(9) == 13 -> True (expected 13)"
        ]
      },
      {
        "task_id": 766,
        "generated_code": "def pair_wise(lst):\n    # Initialize an empty list to store the pairs\n    pairs = []\n    \n    # Iterate through the list with index\n    for i in range(len(lst) - 1):  # Stop one before the last element\n        # Add the current element and the next element as a tuple to the pairs list\n        pairs.append((lst[i], lst[i + 1]))\n    \n    # Return the list of pairs\n    return pairs",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 767,
        "generated_code": "def get_pairs_count(arr, target_sum):\n    count = 0\n    num_occurrences = {}\n\n    for i, num in enumerate(arr):\n        complement = target_sum - num\n        if complement in num_occurrences:\n            count += num_occurrences[complement]\n        if num in num_occurrences:\n            num_occurrences[num] += 1\n        else:\n            num_occurrences[num] = 1\n\n    return count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 769,
        "generated_code": "def assert(\n    Diff(list1, list2)\n):\n    \"\"\"\n    Returns the elements that are in list1 but not in list2.\n    \"\"\"\n    # Convert the lists to sets\n    set1 = set(list1)\n    set2 = set(list2)\n\n    # Calculate the difference between the two sets\n    diff_elements = set1.difference(set2)\n\n    # Return the result as a sorted list\n    return sorted(list(diff_elements))\n\n# Test the function\nassert(Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35]))  # Expected output: [10, 20, 30, 15]",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmptv0acvcj.py\", line 1\n    def assert(\n        ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 770,
        "generated_code": "def odd_num_sum(n):\n    total = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        total += odd_number ** 4\n    return total",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 771,
        "generated_code": "def check_expression(expr):\n    # <analysis>\n    # Initialize an empty stack to keep track of opening parentheses.\n    # Iterate through each character in the expression.\n    # Push opening parentheses onto the stack.\n    # Pop and compare the top of the stack with the current character.\n    # If they don't match, the expression is unbalanced.\n    # Finally, check if the stack is empty after processing the entire expression.\n    # </analysis>\n    \n    stack = []  # Stack to hold opening parentheses\n    \n    for char in expr:\n        if char in [\"(\", \"{\", \"[\"]:\n            stack.append(char)  # Push opening parenthesis onto the stack\n        elif char in [\")\", \"}\", \"]\"]:\n            if not stack:\n                return False  # Unbalanced if stack is empty\n            last_opening = stack.pop()  # Pop the top element from the stack\n            if (char == \")\" and last_opening != \"(\") or \\\n               (char == \"}\" and last_opening != \"{\") or \\\n               (char == \"]\" and last_opening != \"[\"):\n                return False  # Unbalanced if parentheses do not match\n    \n    return len(stack) == 0  # Balanced if stack is empty",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 772,
        "generated_code": "def remove_length(s, k):\n    # Split the string into a list of words\n    words = s.split()\n    \n    # Filter out words with length equal to k\n    filtered_words = [word for word in words if len(word) != k]\n    \n    # Join the filtered list of words back into a single string\n    result = ' '.join(filtered_words)\n    \n    return result\n\n# Test the function\nassert remove_length('The person is most value tet', 3) == 'person is most value'",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 773,
        "generated_code": "def occurance_substring(string, substring):\n    # Check if the substring is empty\n    if not substring:\n        return None\n    \n    # Initialize variables to store the results\n    results = []\n    \n    # Loop through the string to find all occurrences\n    start_index = 0\n    while True:\n        # Find the next occurrence of the substring starting from the current position\n        index = string.find(substring, start_index)\n        \n        # If the substring is not found, break the loop\n        if index == -1:\n            break\n        \n        # Calculate the end position\n        end_index = index + len(substring)\n        \n        # Add the result to the list\n        results.append((substring, index, end_index))\n        \n        # Update the start index for the next search\n        start_index = index + 1\n    \n    # If no results were found, return None\n    if not results:\n        return None\n    \n    # Otherwise, return the results\n    return results",
        "execution_success": false,
        "reward": 0.25,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert occurance_substring('python programming, python language','python')==('python', 0, 6) -> [('python', 0, 6), ('python', 20, 26)] (expected ('python', 0, 6))",
          "assert occurance_substring('python programming,programming language','programming')==('programming', 7, 18) -> [('programming', 7, 18), ('programming', 19, 30)] (expected ('programming', 7, 18))",
          "assert occurance_substring('python programming,programming language','language')==('language', 31, 39) -> [('language', 31, 39)] (expected ('language', 31, 39))"
        ]
      },
      {
        "task_id": 775,
        "generated_code": "def odd_position(nums):\n    # Check for each odd index if the corresponding element is odd\n    for i in range(1, len(nums), 2):  # Iterate over odd indices\n        if nums[i] % 2 == 0:  # Check if the element at odd index is even\n            return False  # Return False if any odd index contains an even number\n    return True  # Return True if all odd indices contain odd numbers\n\n# Test the function\nassert odd_position([2,1,4,3,6,7,6,3]) == True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 776,
        "generated_code": "def count_vowels(s):\n    # Define vowels\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Initialize counter\n    count = 0\n    \n    # Iterate through the string, starting from the second character and ending at the second-to-last character\n    for i in range(1, len(s) - 1):\n        # Check if the current character is surrounded by vowels\n        if s[i-1] in vowels and s[i+1] in vowels:\n            count += 1\n    \n    return count",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert count_vowels('bestinstareels') == 7 -> 1 (expected 7)",
          "assert count_vowels('partofthejourneyistheend') == 12 -> 2 (expected 12)",
          "assert count_vowels('amazonprime') == 5 -> 3 (expected 5)"
        ]
      },
      {
        "task_id": 777,
        "generated_code": "def find_sum(nums):\n    seen = set()  # Initialize an empty set to keep track of seen elements\n    total_sum = 0  # Initialize the sum variable\n    \n    for num in nums:\n        if num not in seen:  # Check if the current element is not in the seen set\n            total_sum += num  # Add the element to the sum if it's not seen before\n            seen.add(num)  # Mark the element as seen\n    \n    return total_sum\n\n# Test the function with the provided test case\nassert find_sum([1,2,3,1,1,4,5,6]) == 21",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 778,
        "generated_code": "def pack_consecutive_duplicates(lst):\n    result = []\n    current_element = lst[0]\n    count = 1\n    \n    for i in range(1, len(lst)):\n        if i == len(lst) - 1 or lst[i] != current_element:\n            result.append([current_element] * count)\n            current_element = lst[i]\n            count = 1\n        else:\n            count += 1\n    \n    return result",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert pack_consecutive_duplicates([0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4])==[[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]] -> [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4]] (expected [[0, 0], [1], [2], [3], [4, 4], [5], [6, 6, 6], [7], [8], [9], [4, 4]])",
          "assert pack_consecutive_duplicates([10, 10, 15, 19, 18, 18, 17, 26, 26, 17, 18, 10])==[[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]] -> [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18]] (expected [[10, 10], [15], [19], [18, 18], [17], [26, 26], [17], [18], [10]])",
          "assert pack_consecutive_duplicates(['a', 'a', 'b', 'c', 'd', 'd'])==[['a', 'a'], ['b'], ['c'], ['d', 'd']] -> [['a', 'a'], ['b'], ['c'], ['d']] (expected [['a', 'a'], ['b'], ['c'], ['d', 'd']])"
        ]
      },
      {
        "task_id": 779,
        "generated_code": "# Example usage\nassert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n#",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmp6c30vw3e.py\", line 2, in <module>\n    assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]]) == {(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n           ^^^^^^^^^^^^^^^\nNameError: name 'unique_sublists' is not defined\n",
        "failed_tests": []
      },
      {
        "task_id": 780,
        "generated_code": "def find_combinations(tuples_list):\n    \"\"\"\n    Finds all possible sums of elements from different tuples in the given list of tuples.\n    \"\"\"\n    unique_sums = set()\n\n    # Iterate over all pairs of tuples\n    for i in range(len(tuples_list)):\n        for j in range(i + 1, len(tuples_list)):\n            # Calculate the sum of elements from both tuples\n            current_sum = (tuples_list[i][0] + tuples_list[j][0], tuples_list[i][1] + tuples_list[j][1])\n            # Add the sum to the set\n            unique_sums.add(current_sum)\n\n    # Convert the set back to a sorted list of tuples\n    return sorted(list(unique_sums))",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_combinations([(2, 4), (6, 7), (5, 1), (6, 10)]) == [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)] -> [(7, 5), (8, 11), (8, 14), (11, 8), (11, 11), (12, 17)] (expected [(8, 11), (7, 5), (8, 14), (11, 8), (12, 17), (11, 11)])",
          "assert find_combinations([(3, 5), (7, 8), (6, 2), (7, 11)]) == [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)] -> [(9, 7), (10, 13), (10, 16), (13, 10), (13, 13), (14, 19)] (expected [(10, 13), (9, 7), (10, 16), (13, 10), (14, 19), (13, 13)])",
          "assert find_combinations([(4, 6), (8, 9), (7, 3), (8, 12)]) == [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)] -> [(11, 9), (12, 15), (12, 18), (15, 12), (15, 15), (16, 21)] (expected [(12, 15), (11, 9), (12, 18), (15, 12), (16, 21), (15, 15)])"
        ]
      },
      {
        "task_id": 781,
        "generated_code": "def count_divisors(n):\n    \"\"\"\n    Function to check whether the count of divisors of a number is even.\n    \n    Args:\n    n (int): The number to check its divisors count.\n    \n    Returns:\n    bool: True if the count of divisors is even, False otherwise.\n    \"\"\"\n    # Initialize the divisor counter\n    divisors_count = 0\n    \n    # Loop through numbers from 1 to n\n    for i in range(1, n + 1):\n        # Check if i is a divisor of n\n        if n % i == 0:\n            # Increment the divisor count\n            divisors_count += 1\n            \n    # Check if the count of divisors is even\n    return divisors_count % 2 == 0",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpelxavfq1.py\", line 24\n    _val = assert count_divisors(10)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 782,
        "generated_code": "def odd_length_sum(arr):\n    n = len(arr)\n    total_sum = 0\n    \n    # Iterate through each element\n    for i in range(n):\n        current_element = arr[i]\n        \n        # Calculate the contribution of the current element\n        contribution = 0\n        for j in range(1, n + 1):\n            if j % 2 != 0:  # Check if j is odd\n                contribution += current_element * ((n - j + 1) // 2)\n        \n        total_sum += contribution\n    \n    return total_sum",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert odd_length_sum([1,2,4]) == 14 -> 7 (expected 14)",
          "assert odd_length_sum([1,2,1,2]) == 15 -> 18 (expected 15)"
        ]
      },
      {
        "task_id": 783,
        "generated_code": "def rgb_to_hsv(r, g, b):\n    # Normalize RGB values\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    \n    # Calculate max and min values\n    max_val = max(r, g, b)\n    min_val = min(r, g, b)\n    delta = max_val - min_val\n    \n    # Calculate chroma\n    C = delta\n    \n    # Calculate hue\n    if C == 0:\n        hue = 0\n    elif r == max_val:\n        hue = (g - b) / delta\n    elif g == max_val:\n        hue = 2 + (b - r) / delta\n    else:\n        hue = 4 + (r - g) / delta\n    \n    hue = hue % 6\n    \n    # Calculate saturation\n    if max_val == 0:\n        saturation = 0\n    else:\n        saturation = delta / max_val\n    \n    # Calculate value\n    value = max_val\n    \n    # Convert hue to degrees\n    hue *= 60\n    \n    return (hue, saturation * 100, value * 100)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 784,
        "generated_code": "def mul_even_odd(nums):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n    \n    # Iterate through the list to find the first even and odd numbers\n    for num in nums:\n        if num % 2 == 0 and (first_even is None or num < first_even):\n            first_even = num\n        elif num % 2 != 0 and (first_odd is None or num < first_odd):\n            first_odd = num\n    \n    # Calculate the product of the first even and odd numbers\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return None  # Return None if no even or odd numbers are found\n\n# Test the function with the provided test case\nassert mul_even_odd([1, 3, 5, 7, 4, 1, 6, 8]) == 4",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 785,
        "generated_code": "def tuple_str_int(s):\n    # Remove outer parentheses\n    s = s[1:-1]\n    \n    # Split the remaining string by commas\n    elements = s.split(\", \")\n    \n    # Convert each element to an integer\n    int_elements = [int(el) for el in elements]\n    \n    # Return the resulting tuple\n    return tuple(int_elements)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 786,
        "generated_code": "def right_insertion(lst, value):\n    left, right = 0, len(lst) - 1\n    \n    while left < right:\n        mid = (left + right) // 2\n        if lst[mid] > value:\n            right = mid\n        else:\n            left = mid + 1\n            \n    return left",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert right_insertion([1,2,4,5],6)==4 -> 3 (expected 4)",
          "assert right_insertion([1,2,4,5],7)==4 -> 3 (expected 4)"
        ]
      },
      {
        "task_id": 787,
        "generated_code": "def text_match_three(text):\n    \"\"\"\n    A function that checks if the input string contains an 'a' followed by exactly three 'b's.\n    \"\"\"\n    import re\n    return bool(re.match(\"^a[b]{3}$\", text))",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmp_up5u4dg.py\", line 8\n    _val = assert not text_match_three(\"ac\")\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 788,
        "generated_code": "def new_tuple(list1, string):\n    # Convert the string into a tuple\n    string_tuple = tuple(string)\n    \n    # Convert the list into a tuple\n    list_tuple = tuple(list1)\n    \n    # Concatenate both tuples\n    result_tuple = string_tuple + list_tuple\n    \n    return result_tuple",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert new_tuple([\"WEB\", \"is\"], \"best\") == ('WEB', 'is', 'best') -> ('b', 'e', 's', 't', 'WEB', 'is') (expected ('WEB', 'is', 'best'))",
          "assert new_tuple([\"We\", \"are\"], \"Developers\") == ('We', 'are', 'Developers') -> ('D', 'e', 'v', 'e', 'l', 'o', 'p', 'e', 'r', 's', 'We', 'are') (expected ('We', 'are', 'Developers'))",
          "assert new_tuple([\"Part\", \"is\"], \"Wrong\") == ('Part', 'is', 'Wrong') -> ('W', 'r', 'o', 'n', 'g', 'Part', 'is') (expected ('Part', 'is', 'Wrong'))"
        ]
      },
      {
        "task_id": 790,
        "generated_code": "def even_position(lst):\n    \"\"\"\n    Check if every element at an even index is even.\n    \"\"\"\n    for i in range(0, len(lst), 2):  # Step by 2 to only consider even indices\n        if lst[i] % 2 != 0:  # Check if the number at the current even index is odd\n            return False\n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 791,
        "generated_code": "def remove_nested(tup):\n    result = ()\n    for item in tup:\n        if not isinstance(item, tuple):\n            result += (item,)\n    return result\n\n# Test the function\nassert remove_nested((1, 5, 7, (4, 6), 10)) == (1, 5, 7, 10)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 792,
        "generated_code": "def count_list(lst):\n    \"\"\"\n    Counts the number of sublists within a given list of lists.\n    \"\"\"\n    sublist_count = 0\n    \n    for item in lst:\n        if isinstance(item, list) and len(item) > 1:\n            sublist_count += 1\n    \n    return sublist_count\n\n# Test Case\nassert count_list([[1, 3], [5, 7], [9, 11], [13, 15, 17]]) == 4",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 793,
        "generated_code": "def last(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid  # Update the result to mid\n            left = mid + 1  # Move left to find the last occurrence\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 794,
        "generated_code": "import re\n\ndef text_starta_endb(text):\n    # Define the regex pattern to match strings starting with 'a', followed by any characters, and ending with 'b'\n    pattern = '^a.*b$'\n    \n    # Use re.match to check if the entire string matches the pattern\n    if re.match(pattern, text):\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert text_starta_endb(\"aabbbb\") == True",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpzju35m9d.py\", line 16\n    _val = assert text_starta_endb(\"aabbbb\")\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 796,
        "generated_code": "def return_sum(d):\n    \"\"\"\n    Returns the sum of all values in the given dictionary.\n    \"\"\"\n    total = 0\n    for value in d.values():\n        total += value\n    return total",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 797,
        "generated_code": "def sum_in_range(l, r):\n    # Handle edge cases where the range does not contain any odd numbers\n    if l > r or (l % 2 == 0 and r % 2 == 0):\n        return 0\n\n    # Start with the first odd number in the range\n    first_odd = l + (1 - l % 2)\n    \n    # Sum the odd numbers using a generator expression\n    return sum(x for x in range(first_odd, r+1, 2))",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 798,
        "generated_code": "def _sum(arr):\n    total = 0  # Initialize sum to 0\n    for num in arr:  # Iterate over each element in the array\n        total += num  # Add the current element to the total\n    return total  # Return the total sum",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 799,
        "generated_code": "def left_rotate(num, d):\n    # Ensure d is within the range [0, 32]\n    d = d % 32\n    \n    # Step 1: Right shift by (32 - d) bits\n    right_shifted = num >> (32 - d)\n    \n    # Step 2: Left shift by d bits\n    left_shifted = num << d\n    \n    # Step 3: Combine the results by masking the right-shifted value into the appropriate positions\n    return (left_shifted | right_shifted) & ((1 << 32) - 1)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 800,
        "generated_code": "def remove_all_spaces(s):\n    \"\"\"\n    Removes all whitespaces from the input string s.\n    \"\"\"\n    # Replace all whitespace characters with an empty string\n    return s.replace(\" \", \"\")",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 801,
        "generated_code": "def test_three_equal(a, b, c):\n    # XOR the three numbers\n    xor_result = a ^ b ^ c\n    \n    # Check if the result is zero (all numbers are equal)\n    if xor_result == 0:\n        return 3\n    else:\n        return 0",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert test_three_equal(1,1,1) == 3 -> 0 (expected 3)",
          "assert test_three_equal(1,2,2) == 2 -> 0 (expected 2)"
        ]
      },
      {
        "task_id": 802,
        "generated_code": "def count_rotation(arr):\n    \"\"\"\n    Counts the number of rotations required to generate a sorted array.\n    \n    Parameters:\n    arr (list): The rotated array.\n    \n    Returns:\n    int: The number of rotations.\n    \"\"\"\n    low = 0\n    high = len(arr) - 1\n    \n    while low < high:\n        mid = (low + high) // 2\n        \n        # Check if mid is the pivot\n        if mid > 0 and arr[mid] < arr[mid - 1]:\n            return mid\n        \n        # Decide the search range\n        if arr[mid] < arr[high]:\n            high = mid\n        else:\n            low = mid + 1\n    \n    return 0",
        "execution_success": false,
        "reward": 0.8,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert count_rotation([1,3,2]) == 2 -> 0 (expected 2)"
        ]
      },
      {
        "task_id": 803,
        "generated_code": "import math\n\ndef is_perfect_square(n):\n    # Handle edge cases\n    if n == 0 or n == 1:\n        return True\n    \n    # Compute the square root\n    sqrt_n = math.sqrt(n)\n    \n    # Check if the square root is an integer\n    return sqrt_n == round(sqrt_n)\n\n# Test the function\nassert is_perfect_square(10) == False  # This should pass as 10 is not a perfect square",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmp99a0it2q.py\", line 17\n    _val = assert not is_perfect_square(10)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 804,
        "generated_code": "def is_product_even(numbers):\n    is_even = False\n    \n    for num in numbers:\n        if num % 2 == 0:\n            is_even = True\n            break\n            \n    return is_even",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpvjdohbmq.py\", line 11\n    _val = assert is_product_even([1,2,3])\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 805,
        "generated_code": "def max_sum_list(\n    list_of_lists\n):\n    max_sum = float('-inf')\n    max_list = []\n\n    for sublist in list_of_lists:\n        current_sum = sum(sublist)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = sublist\n\n    return max_list",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 806,
        "generated_code": "def max_run_uppercase(s):\n    max_run = 0  # Initialize the maximum run of uppercase characters\n    current_run = 0  # Initialize the current run of uppercase characters\n    \n    for char in s:\n        if char.isupper():\n            current_run += 1  # Increment the current run if the character is uppercase\n        else:\n            current_run = 0  # Reset the current run if the character is not uppercase\n        \n        max_run = max(max_run, current_run)  # Update the maximum run if the current run is greater\n    \n    return max_run\n\n# Test the function\nassert max_run_uppercase('GeMKSForGERksISBESt') == 5",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 807,
        "generated_code": "def first_odd(numbers):\n    # Iterate through the list\n    for number in numbers:\n        # Check if the number is odd\n        if number % 2 != 0:\n            return number\n    # If no odd number is found, return None or raise an exception (depending on the requirements)\n    return None",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 808,
        "generated_code": "def check_K(tup, k):\n    \"\"\"\n    Check if the given tuple contains the specified value k.\n\n    Parameters:\n    tup (tuple): The tuple to search through.\n    k (int/float): The value to find in the tuple.\n\n    Returns:\n    bool: True if k is in tup, False otherwise.\n    \"\"\"\n    return k in tup",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 809,
        "generated_code": "def check_smaller(tuple1, tuple2):\n    for i in range(len(tuple1)):\n        if tuple2[i] >= tuple1[i]:\n            return False\n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 554,
        "generated_code": "def Split(numbers):\n    \"\"\"\n    Takes a list of integers and returns a new list containing only the odd integers.\n    \"\"\"\n    odd_numbers = []\n    for num in numbers:\n        if num % 2 != 0:\n            odd_numbers.append(num)\n    return odd_numbers\n\n# Test Case\nassert Split([1, 2, 3, 4, 5, 6]) == [1, 3, 5]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 555,
        "generated_code": "def difference(\n    n\n):\n    return (n * (n + 1) * (n - 1) * (n + 2)) // 4",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 556,
        "generated_code": "def find_Odd_Pair(arr, n):\n    # Count the number of odd and even elements in the array\n    odd_count = sum(1 for num in arr if num % 2 != 0)\n    even_count = len(arr) - odd_count\n    \n    # Calculate the number of pairs with odd XOR\n    odd_pairs = odd_count * (odd_count - 1) // 2\n    even_pairs = odd_count * even_count\n    \n    return odd_pairs + even_pairs",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_Odd_Pair([5,4,7,2,1],5) == 6 -> 9 (expected 6)",
          "assert find_Odd_Pair([7,2,8,1,0,5,11],7) == 12 -> 18 (expected 12)",
          "assert find_Odd_Pair([1,2,3],3) == 2 -> 3 (expected 2)"
        ]
      },
      {
        "task_id": 557,
        "generated_code": "def toggle_string(s):\n    # Initialize an empty string to store the result\n    result = \"\"\n    \n    # Iterate through each character in the input string\n    for char in s:\n        # Toggle the case of the character\n        if char.isupper():\n            result += char.lower()\n        else:\n            result += char.upper()\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 558,
        "generated_code": "def digit_distance_nums(a, b):\n        # Convert the integers to strings for easy digit comparison\n        str_a, str_b = str(a), str(b)\n        \n        # Initialize the result to store the total digit distance\n        result = 0\n        \n        # Ensure both strings are of equal length by padding with zeros\n        max_length = max(len(str_a), len(str_b))\n        str_a_padded = str_a.zfill(max_length)\n        str_b_padded = str_b.zfill(max_length)\n        \n        # Iterate through each digit and compute the absolute difference\n        for i in range(max_length):\n            diff = abs(int(str_a_padded[i]) - int(str_b_padded[i]))\n            result += diff\n        \n        return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 559,
        "generated_code": "def max_sub_array_sum(nums, max_length):\n    if not nums:\n        return 0\n    \n    max_current = max_global = nums[0]\n    \n    for i in range(1, len(nums)):\n        max_current = max(nums[i], max_current + nums[i])\n        if max_current > max_global:\n            max_global = max_current\n    \n    return max_global",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 560,
        "generated_code": "def union_elements(tuple1, tuple2):\n    # Combine the tuples into one\n    combined_tuple = tuple1 + tuple2\n    \n    # Remove duplicates by converting to a set\n    unique_values = set(combined_tuple)\n    \n    # Convert the set back to a sorted list\n    sorted_unique_values = sorted(list(unique_values))\n    \n    return sorted_unique_values",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert union_elements((3, 4, 5, 6),(5, 7, 4, 10) ) == (3, 4, 5, 6, 7, 10) -> [3, 4, 5, 6, 7, 10] (expected (3, 4, 5, 6, 7, 10))",
          "assert union_elements((1, 2, 3, 4),(3, 4, 5, 6) ) == (1, 2, 3, 4, 5, 6) -> [1, 2, 3, 4, 5, 6] (expected (1, 2, 3, 4, 5, 6))",
          "assert union_elements((11, 12, 13, 14),(13, 15, 16, 17) ) == (11, 12, 13, 14, 15, 16, 17) -> [11, 12, 13, 14, 15, 16, 17] (expected (11, 12, 13, 14, 15, 16, 17))"
        ]
      },
      {
        "task_id": 562,
        "generated_code": "def Find_Max_Length(list_of_lists):\n    max_length = 0\n    \n    for sublist in list_of_lists:\n        current_length = len(sublist)\n        if current_length > max_length:\n            max_length = current_length\n            \n    return max_length",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 563,
        "generated_code": "import re\n\ndef extract_values(input_string):\n    # Use regular expression to find all substrings enclosed in double quotes\n    matches = re.findall(r'\"(.*?)\"', input_string)\n    \n    # Convert matches to a list of strings and return\n    return matches\n\n# Test the function with the provided test case\nassert extract_values('\"Python\", \"PHP\", \"Java\"') == ['Python', 'PHP', 'Java']",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 564,
        "generated_code": "def count_Pairs(nums):\n    from collections import Counter\n    \n    # Count the frequency of each element in the list\n    freq = Counter(nums)\n    \n    # Calculate the total number of pairs if all elements were distinct\n    total_pairs = len(nums) * (len(nums) - 1) // 2\n    \n    # Subtract the number of pairs formed by identical elements\n    for count in freq.values():\n        if count > 1:\n            total_pairs -= count * (count - 1) // 2\n    \n    return total_pairs\n\n# Test the function\nassert count_Pairs([1,2,1]) == 2",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert count_Pairs([1,2,1],3) == 2 -> TypeError: count_Pairs() takes 1 positional argument but 2 were given",
          "assert count_Pairs([1,1,1,1],4) == 0 -> TypeError: count_Pairs() takes 1 positional argument but 2 were given",
          "assert count_Pairs([1,2,3,4,5],5) == 10 -> TypeError: count_Pairs() takes 1 positional argument but 2 were given"
        ]
      },
      {
        "task_id": 565,
        "generated_code": "def split(s):\n    # Initialize an empty list to store characters\n    result = []\n    \n    # Loop through each character in the string\n    for char in s:\n        # Append each character to the result list\n        result.append(char)\n    \n    # Return the list of characters\n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 566,
        "generated_code": "def sum_digits(n):\n    # Convert the integer to a string\n    num_str = str(n)\n    \n    # Initialize the sum to 0\n    digit_sum = 0\n    \n    # Iterate over each character in the string\n    for char in num_str:\n        # Convert the character back to an integer and add it to the sum\n        digit_sum += int(char)\n    \n    # Return the total sum of the digits\n    return digit_sum",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 567,
        "generated_code": "def issort_list(lst):\n    # Check that all pairs of consecutive elements are in non-decreasing order\n    return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 568,
        "generated_code": "def empty_list(N):\n    \"\"\"\n    Creates a list containing N empty dictionaries.\n    \n    :param N: Number of empty dictionaries to generate.\n    :return: List of N empty dictionaries.\n    \"\"\"\n    return [{}) * N  # List comprehension to create N empty dictionaries",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpdok0r8h6.py\", line 8\n    return [{}) * N  # List comprehension to create N empty dictionaries\n              ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '['\n",
        "failed_tests": []
      },
      {
        "task_id": 569,
        "generated_code": "def sort_sublists(lst):\n    # Iterate through each sublist and sort it\n    for i in range(len(lst)):\n        lst[i] = sorted(lst[i])\n    return lst",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 572,
        "generated_code": "def two_unique_nums(lists):\n    # Flatten the list of lists\n    flat_list = [num for sublist in lists for num in sublist]\n    \n    # Remove duplicates by converting to a set and back to a list\n    unique_nums = list(set(flat_list))\n    \n    return unique_nums",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert two_unique_nums([1,2,3,2,3,4,5]) == [1, 4, 5] -> TypeError: 'int' object is not iterable",
          "assert two_unique_nums([1,2,3,2,4,5]) == [1, 3, 4, 5] -> TypeError: 'int' object is not iterable",
          "assert two_unique_nums([1,2,3,4,5]) == [1, 2, 3, 4, 5] -> TypeError: 'int' object is not iterable"
        ]
      },
      {
        "task_id": 573,
        "generated_code": "def unique_product(numbers):\n    # Step 1: Remove duplicates\n    unique_numbers = list(set(numbers))\n    \n    # Step 2: Calculate product\n    if len(unique_numbers) == 0:\n        return 1\n    else:\n        product = 1\n        for num in unique_numbers:\n            product *= num\n    \n    return product",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 574,
        "generated_code": "def surfacearea_cylinder(radius, height):\n    # Surface area calculation\n    return 2 * 3.14159 * radius**2 + 2 * 3.14159 * radius * height\n\n# Test case\nassert surfacearea_cylinder(5, 10) == 942.45",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmp2065p63m.py\", line 6, in <module>\n    assert surfacearea_cylinder(5, 10) == 942.45\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 576,
        "generated_code": "def is_Sub_Array(larger, smaller):\n    # Check if smaller list is longer than larger list\n    if len(smaller) > len(larger):\n        return False\n    \n    # Initialize pointers\n    i = 0\n    j = 0\n    \n    # Iterate through larger list with pointer i\n    while i < len(larger) and j < len(smaller):\n        if larger[i] == smaller[j]:\n            j += 1\n        i += 1\n    \n    # If we've matched all elements of smaller in the larger list\n    return j == len(smaller)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 577,
        "generated_code": "def last_Digit_Factorial(n):\n    # Special cases for small n\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    \n    # For n >= 5, the last digit is always 0\n    return 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 578,
        "generated_code": "def interleave_lists(list1, list2, list3):\n    \"\"\"\n    Interleave three lists of the same length into a single flat list.\n    \n    Args:\n    list1 (List[int]): First input list.\n    list2 (List[int]): Second input list.\n    list3 (List[int]): Third input list.\n    \n    Returns:\n    List[int]: A single flat list containing elements from list1, list2, and list3 in interleaved order.\n    \"\"\"\n    result = []\n    for i in range(len(list1)):\n        result.append(list1[i])\n        result.append(list2[i])\n        result.append(list3[i])\n    return result\n\n# Test case\nassert interleave_lists([1,2,3,4,5,6,7], [10,20,30,40,50,60,70], [100,200,300,400,500,600,700]) == [1, 10, 100, 2, 20, 200, 3, 30, 300, 4, 40, 400, 5, 50, 500, 6, 60, 600, 7, 70, 700]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 579,
        "generated_code": "def find_dissimilar(t1, t2):\n    \"\"\"\n    Finds dissimilar elements between two tuples.\n    \n    :param t1: First tuple\n    :param t2: Second tuple\n    :return: A tuple containing dissimilar elements\n    \"\"\"\n    # Convert tuples to sets for efficient intersection operation\n    set_t1 = set(t1)\n    set_t2 = set(t2)\n    \n    # Find elements in either set but not in both (dissimilar elements)\n    dissimilar_elements = (set_t1 ^ set_t2)\n    \n    return tuple(dissimilar_elements)\n\n# Test the function with the provided test case\nassert find_dissimilar((3, 4, 5, 6), (5, 7, 4, 10)) == (3, 6, 7, 10)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 580,
        "generated_code": "def extract_even(\n    nested_tuple\n):\n    result = ()\n    \n    for element in nested_tuple:\n        if isinstance(element, int):  # Check if the element is an integer\n            if element % 2 == 0:  # If the integer is even\n                result += (element,)\n        elif isinstance(element, tuple):  # If the element is a tuple\n            filtered_element = extract_even(element)  # Recursively process the tuple\n            if filtered_element:  # Only add non-empty tuples\n                result += (filtered_element,)\n                \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 581,
        "generated_code": "def surface_Area(side, height):\n    # Base area calculation\n    base_area = side ** 2\n    \n    # Slant height calculation\n    slant_height = (side / 2) ** 2 + height ** 2\n    \n    # Area of one triangular face\n    triangle_area = 0.5 * side * slant_height\n    \n    # Lateral surface area calculation\n    lateral_surface_area = 4 * triangle_area\n    \n    # Total surface area calculation\n    total_surface_area = base_area + lateral_surface_area\n    \n    return total_surface_area",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert surface_Area(3,4) == 33 -> 118.5 (expected 33)",
          "assert surface_Area(4,5) == 56 -> 248.0 (expected 56)",
          "assert surface_Area(1,2) == 5 -> 9.5 (expected 5)"
        ]
      },
      {
        "task_id": 582,
        "generated_code": "def my_dict(d):\n    return len(d) == 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 583,
        "generated_code": "from math import comb\n\ndef catalan_number(n):\n    \"\"\"\n    Computes the nth Catalan number.\n    \n    Parameters:\n    n (int): The index of the Catalan number to compute.\n    \n    Returns:\n    int: The nth Catalan number.\n    \"\"\"\n    # Using the formula C_n = 1/(n+1) * (2n choose n)\n    return comb(2*n, n) // (n + 1)\n\n# Test case to verify correctness\nassert catalan_number(10) == 16796",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 584,
        "generated_code": "def find_adverbs(sentence):\n    # Split the sentence into words\n    words = sentence.split()\n    \n    # Initialize variables to store the result\n    result = []\n    \n    # Iterate over each word\n    for i, word in enumerate(words):\n        # Check if the word ends with 'ly'\n        if word.endswith('ly'):\n            # Append the word and its indices to the result list\n            result.append(f\"{i}-{i+len(word)}: {word}\")\n    \n    # Join the results with a colon separator\n    return ': '.join(result)",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert find_adverbs(\"Clearly, he has no excuse for such behavior.\") == '0-7: Clearly' -> '' (expected '0-7: Clearly')",
          "assert find_adverbs(\"Please handle the situation carefuly\") == '28-36: carefuly' -> '4-12: carefuly' (expected '28-36: carefuly')",
          "assert find_adverbs(\"Complete the task quickly\") == '18-25: quickly' -> '3-10: quickly' (expected '18-25: quickly')"
        ]
      },
      {
        "task_id": 585,
        "generated_code": "def expensive_items(items, n):\n    # Sort the items by price in descending order\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    \n    # Select the top n items\n    top_n_items = sorted_items[:n]\n    \n    return top_n_items\n\n# Test the function with the provided test case\nassert expensive_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1) == [{'name': 'Item-2', 'price': 555.22}]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 586,
        "generated_code": "def split_Arr(arr, n):\n    \"\"\"\n    Splits a list at the nth element and adds the first part to the end.\n    \n    :param arr: List of integers\n    :param n: Index of the element to split the list at\n    :return: Modified list with the first part added to the end\n    \"\"\"\n    # Ensure n is within the bounds of the list\n    if n >= len(arr):\n        return arr  # If n is out of bounds, return the original list\n    \n    # Split the list\n    first_part = arr[:n]\n    second_part = arr[n:]\n    \n    # Recombine the list\n    result = second_part + first_part\n    \n    return result\n\n# Test the function\nassert split_Arr([12,10,5,6,52,36], 2) == [5,6,52,36,12,10]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 587,
        "generated_code": "def list_tuple(lst):\n    \"\"\"\n    Convert a list to a tuple.\n\n    :param lst: List of elements to be converted.\n    :return: Tuple containing the elements of the list.\n    \"\"\"\n    return tuple(lst)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 588,
        "generated_code": "def big_diff(nums):\n    # Analysis:\n    # 1. The maximum value can be found using max(nums).\n    # 2. The minimum value can be found using min(nums).\n    # 3. The difference between the maximum and minimum values is max(nums) - min(nums).\n\n    # Code:\n    return max(nums) - min(nums)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 589,
        "generated_code": "def perfect_squares(start, end):\n    result = []\n    \n    for n in range(start, end + 1):\n        sqrt_n = n ** 0.5\n        if int(sqrt_n) == sqrt_n:\n            result.append(n)\n    \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 590,
        "generated_code": "def polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return ((x, y), (complex(x, y)))",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert polar_rect(3,4)==((5.0, 0.9272952180016122), (-2+2.4492935982947064e-16j)) -> NameError: name 'math' is not defined",
          "assert polar_rect(4,7)==((8.06225774829855, 1.0516502125483738), (-2+2.4492935982947064e-16j)) -> NameError: name 'math' is not defined",
          "assert polar_rect(15,17)==((22.67156809750927, 0.8478169733934057), (-2+2.4492935982947064e-16j)) -> NameError: name 'math' is not defined"
        ]
      },
      {
        "task_id": 591,
        "generated_code": "def swap_List(lst):\n    # Move the first element to the end\n    lst.append(lst.pop(0))\n    \n    return lst",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert swap_List([12, 35, 9, 56, 24]) == [24, 35, 9, 56, 12] -> [35, 9, 56, 24, 12] (expected [24, 35, 9, 56, 12])",
          "assert swap_List([1, 2, 3]) == [3, 2, 1] -> [2, 3, 1] (expected [3, 2, 1])",
          "assert swap_List([4, 5, 6]) == [6, 5, 4] -> [5, 6, 4] (expected [6, 5, 4])"
        ]
      },
      {
        "task_id": 592,
        "generated_code": "def sum_Of_product(n):\n    # Test with small values\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    \n    # Calculate the sum of the product of consecutive binomial coefficients\n    total_sum = 0\n    for k in range(n):\n        total_sum += (n * binomial_coefficient(n, k) / (k + 1))\n    \n    return int(total_sum)\n\ndef binomial_coefficient(n, k):\n    # Helper function to calculate binomial coefficient\n    return factorial(n) // (factorial(k) * factorial(n - k))\n\ndef factorial(x):\n    # Helper function to calculate factorial\n    if x == 0 or x == 1:\n        return 1\n    else:\n        result = 1\n        for i in range(2, x + 1):\n            result *= i\n        return result\n\n# Test case\nassert sum_Of_product(3) == 15",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpnncd_0kw.py\", line 30, in <module>\n    assert sum_Of_product(3) == 15\n           ^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 593,
        "generated_code": "def removezero_ip(ip_address):\n    # Split the IP address into octets\n    octets = ip_address.split('.')\n    \n    # Process each octet\n    cleaned_octets = []\n    for octet in octets:\n        # Remove leading zeros from each octet\n        cleaned_octet = str(int(octet))\n        cleaned_octets.append(cleaned_octet)\n    \n    # Join the cleaned octets back into a single string with dots\n    cleaned_ip = '.'.join(cleaned_octets)\n    \n    return cleaned_ip",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 594,
        "generated_code": "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    \n    for num in lst:\n        if num % 2 == 0:  # Check if the number is even\n            if first_even is None:\n                first_even = num\n        else:  # The number is odd\n            if first_odd is None:\n                first_odd = num\n                \n    if first_even is None or first_odd is None:\n        return 0  # If no even or odd number found, return 0\n    \n    return first_even - first_odd",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 595,
        "generated_code": "def min_Swaps(binary_str1, binary_str2):\n    # Step 1: Identify differing positions\n    diff_positions = []\n    for i in range(len(binary_str1)):\n        if binary_str1[i] != binary_str2[i]:\n            diff_positions.append(i)\n    \n    # Step 2: Count minimum swaps\n    swaps_needed = 0\n    for pos in diff_positions:\n        # Check if a swap is necessary at the current position\n        if (pos > 0 and binary_str1[pos-1] == binary_str2[pos-1]) or \\\n           (pos < len(binary_str1)-1 and binary_str1[pos+1] == binary_str2[pos+1]):\n            swaps_needed += 1\n    \n    return swaps_needed",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert min_Swaps(\"111\",\"000\") == \"Not Possible\" -> 0 (expected 'Not Possible')",
          "assert min_Swaps(\"111\",\"110\") == \"Not Possible\" -> 1 (expected 'Not Possible')"
        ]
      },
      {
        "task_id": 596,
        "generated_code": "import sys\n\ndef tuple_size(tup):\n    # Count the number of strings and integers in the tuple\n    num_strings = sum(isinstance(item, str) for item in tup)\n    num_integers = sum(isinstance(item, int) for item in tup)\n\n    # Calculate the size of string elements\n    size_of_string = sys.getsizeof(\"A\")  # Assume a string takes 1 byte\n    total_size_strings = num_strings * size_of_string\n\n    # Calculate the size of integer elements\n    size_of_integer = sys.getsizeof(0)  # Assume an integer takes 4 bytes\n    total_size_integers = num_integers * size_of_integer\n\n    # Return the total size\n    return total_size_strings + total_size_integers\n\n# Test the function\nassert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmp0y2rumxz.py\", line 20, in <module>\n    assert tuple_size((\"A\", 1, \"B\", 2, \"C\", 3)) == sys.getsizeof((\"A\", 1, \"B\", 2, \"C\", 3))\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 597,
        "generated_code": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth smallest element in the union of two sorted arrays.\n\n    :param arr1: List[int] -- First sorted array.\n    :param arr2: List[int] -- Second sorted array.\n    :param k: int -- The kth position to find.\n    :return: int -- The kth smallest element.\n    \"\"\"\n\n    # Helper function to perform binary search\n    def binary_search(arr1, arr2, k):\n        left, right = 0, min(k, len(arr1))\n\n        while left < right:\n            mid = (left + right) // 2\n            if arr1[mid] > arr2[k - mid - 1]:\n                right = mid\n            else:\n                left = mid + 1\n\n        return left\n\n    # Determine which array contains the kth element\n    if len(arr1) > len(arr2):\n        return binary_search(arr1, arr2, k)\n    else:\n        return binary_search(arr2, arr1, k)\n\n\n# Test the function\nassert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpvi3hznuj.py\", line 32, in <module>\n    assert find_kth([2, 3, 6, 7, 9], [1, 4, 8, 10], 5) == 6\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 598,
        "generated_code": "def armstrong_number(n):\n    # Convert the number to a string to iterate over each digit\n    num_str = str(n)\n    \n    # Calculate the number of digits\n    num_digits = len(num_str)\n    \n    # Compute the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in num_str)\n    \n    # Check if the computed sum is equal to the original number\n    return sum_of_powers == n",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 599,
        "generated_code": "def sum_average(n):\n    # Calculate the sum using the formula\n    sum_natural_numbers = n * (n + 1) // 2\n    \n    # Calculate the average\n    average_natural_numbers = (n + 1) / 2\n    \n    return sum_natural_numbers, average_natural_numbers",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 600,
        "generated_code": "def is_Even(n):\n    # Check if the number is divisible by 2 without any remainder\n    return n % 2 == 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 11,
        "generated_code": "def remove_Occ(s, char):\n    # Find all positions of the character\n    positions = [i for i, c in enumerate(s) if c == char]\n    \n    # If there is no such character, return the original string\n    if not positions:\n        return s\n    \n    # Get the first and last position\n    first_pos = positions[0]\n    last_pos = positions[-1]\n    \n    # Remove the first and last occurrence\n    result = s[:first_pos] + s[last_pos+1:]\n    \n    return result",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert remove_Occ(\"abcda\",\"a\") == \"bcd\" -> '' (expected 'bcd')",
          "assert remove_Occ(\"PHP\",\"P\") == \"H\" -> '' (expected 'H')"
        ]
      },
      {
        "task_id": 12,
        "generated_code": "def sort_matrix(matrix):\n    # Step 1: Calculate the sum of each row\n    row_sums = [sum(row) for row in matrix]\n    \n    # Step 2: Sort the matrix rows based on their sums\n    sorted_matrix = [row for _, row in sorted(zip(row_sums, matrix), key=lambda pair: pair[0])]\n    \n    return sorted_matrix",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 14,
        "generated_code": "def find_Volume(b1, ht, hp):\n    # Calculate the base area of the triangular base\n    base_area = 0.5 * b1 * ht\n    \n    # Calculate the volume of the triangular prism\n    volume = base_area * hp\n    \n    return volume\n</code>",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpnu9iz2f5.py\", line 9\n    </code>\n    ^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 16,
        "generated_code": "import re\n\ndef text_lowercase_underscore(text):\n    \"\"\"\n    Checks if the input string contains sequences of lowercase letters joined with an underscore.\n    \n    Args:\n    text (str): Input string to check.\n    \n    Returns:\n    bool: True if the string matches the pattern, False otherwise.\n    \"\"\"\n    # Define the regex pattern: one or more lowercase letters followed by an underscore\n    pattern = r\"[a-z]+_[a-z]+\"\n    \n    # Search for the pattern in the input string\n    match = re.search(pattern, text)\n    \n    # Return True if a match is found, False otherwise\n    return bool(match)\n\n# Test the function\nassert text_lowercase_underscore(\"aab_cbbbc\") == True",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert text_lowercase_underscore(\"Aaab_abbbc\")==(False) -> True (expected False)"
        ]
      },
      {
        "task_id": 17,
        "generated_code": "def square_perimeter(side_length):\n    return 4 * side_length",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 18,
        "generated_code": "def remove_dirty_chars(string1, string2):\n    result = ''\n    for char in string1:\n        if char not in string2:\n            result += char\n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 19,
        "generated_code": "def test_duplicate(\n    nums\n):\n    # Convert the list to a set and compare lengths\n    return len(nums) != len(set(nums))",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 20,
        "generated_code": "def is_woodall(k):\n    n = 1\n    while True:\n        if n * (2 ** n) - 1 == k:\n            return True\n        elif n * (2 ** n) > k:\n            return False\n        n += 1",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 56,
        "generated_code": "def check(n):\n    # Step 1: Reverse the number\n    reversed_n = int(str(n)[::-1])\n    \n    # Step 2: Check the condition\n    return n == 2 * reversed_n - 1\n\n# Analysis:\n# Given a number n, let's say the reversed number is rev_n.\n# We need to check if n == 2 * rev_n - 1.\n# If true, then the condition holds. Otherwise, it does not.\n\n# Test case:\nassert check(70) == False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 57,
        "generated_code": "def find_Max_Num(digits):\n    # Sorting the digits in descending order\n    digits.sort(reverse=True)\n    \n    # Joining the digits to form the number\n    max_num = int(''.join(map(str, digits)))\n    \n    return max_num",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 58,
        "generated_code": "def opposite_Signs(a, b):\n    # Check if any number is zero\n    if a == 0 or b == 0:\n        return False\n\n    # Check if both numbers have different signs\n    return a * b < 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 59,
        "generated_code": "def is_octagonal(n):\n    return n * (3 * n - 2)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 61,
        "generated_code": "def count_Substrings(s):\n    n = len(s)\n    count = 0\n    \n    # Iterate over all possible starting points of the substring\n    for start in range(n):\n        total_sum = 0\n        \n        # Iterate over all possible ending points of the substring\n        for end in range(start, n):\n            # Convert the substring to an integer and check the condition\n            substring = s[start:end+1]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n                \n    return count\n\n# Test the function\nassert count_Substrings('112112') == 6",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 62,
        "generated_code": "def smallest_num(lst):\n    if not lst:\n        return None  # Return None for empty list\n    \n    smallest = lst[0]  # Assume the first element is the smallest\n    \n    for num in lst[1:]:\n        if num < smallest:\n            smallest = num\n    \n    return smallest",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 63,
        "generated_code": "def max_difference(\n    tuples_list\n):\n    max_diff = float('-inf')\n    \n    for pair in tuples_list:\n        a, b = pair\n        diff = b - a\n        max_diff = max(max_diff, diff)\n    \n    return max_diff",
        "execution_success": false,
        "reward": 0.6666666666666666,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7 -> 6 (expected 7)"
        ]
      },
      {
        "task_id": 64,
        "generated_code": "def subject_marks(subject_marks):\n    # Use sorted() with a lambda function as the key to sort by the second element of each tuple\n    return sorted(subject_marks, key=lambda x: x[1])\n\n# Test the function\nassert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 65,
        "generated_code": "def recursive_list_sum(lst):\n    total_sum = 0\n    \n    for item in lst:\n        if isinstance(item, list):  # Check if item is a list\n            total_sum += recursive_list_sum(item)  # Recursively sum items in the sublist\n        else:\n            total_sum += item  # Add non-list items directly\n            \n    return total_sum",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 66,
        "generated_code": "def pos_count(lst):\n    \"\"\"\n    Counts the number of positive integers in the provided list.\n    \n    :param lst: List of integers\n    :return: Integer representing the count of positive numbers in the list\n    \"\"\"\n    # Initialize counter\n    count = 0\n    \n    # Iterate through the list\n    for num in lst:\n        # Check if the number is positive\n        if num > 0:\n            # Increment the counter\n            count += 1\n            \n    # Return the count of positive numbers\n    return count\n\n# Test the function\nassert pos_count([1, -2, 3, -4]) == 2",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 67,
        "generated_code": "def bell_number(n):\n    # Base cases\n    if n == 0:\n        return 1\n    if n == 1:\n        return 1\n    \n    # Initialize the list to store Bell numbers\n    bell = [0] * (n + 1)\n    bell[0], bell[1] = 1, 1\n    \n    # Compute Bell numbers iteratively\n    for i in range(2, n + 1):\n        bell[i] = sum(bell[j] * bell[i - j - 1] for j in range(i))\n    \n    return bell[n]",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert bell_number(10)==115975 -> 16796 (expected 115975)",
          "assert bell_number(56)==6775685320645824322581483068371419745979053216268760300 -> 6852456927844873497549658464312 (expected 6775685320645824322581483068371419745979053216268760300)"
        ]
      },
      {
        "task_id": 68,
        "generated_code": "def is_Monotonic(arr):\n    # Check if the array is non-decreasing\n    is_non_decreasing = all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1))\n    \n    # Check if the array is non-increasing\n    is_non_increasing = all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1))\n    \n    # The array is monotonic if it is either non-decreasing or non-increasing\n    return is_non_decreasing or is_non_increasing",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 69,
        "generated_code": "def is_sublist(main_list, sub_list):\n    # Check if the lengths of both lists are valid\n    if len(sub_list) > len(main_list):\n        return False\n    \n    # Check if the lists are identical\n    if main_list == sub_list:\n        return True\n    \n    # Iterate through the main list to find the sublist\n    for i in range(len(main_list) - len(sub_list) + 1):\n        if main_list[i:i+len(sub_list)] == sub_list:\n            return True\n            \n    return False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 70,
        "generated_code": "def get_equal(tuples_list):\n    # Get the length of the first tuple\n    first_tuple_length = len(tuples_list[0])\n    \n    # Check if all tuples have the same length as the first one\n    for tpl in tuples_list:\n        if len(tpl) != first_tuple_length:\n            return False\n    \n    return True",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 71,
        "generated_code": "def comb_sort(arr):\n    # Initial gap size\n    gap = len(arr)\n    # Shrink factor\n    shrink_factor = 1.3\n    swapped = True\n\n    while gap > 1 or swapped:\n        # Update gap and swapped flag\n        gap = int(gap / shrink_factor)\n        swapped = False\n\n        # Perform a gap-based sort\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 72,
        "generated_code": "def dif_Square(n):\n    # Check if n is odd and not divisible by 4\n    return n % 2 != 0 and n % 4 != 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 74,
        "generated_code": "def is_samepatterns(patterns, given_sequence):\n    # Create a mapping from elements of the first list to the second list\n    mapping = {pattern[0]: pattern[1] for pattern in patterns}\n    \n    # Apply the mapping to the given sequence\n    transformed_sequence = [mapping.get(item, item) for item in given_sequence]\n    \n    # Check if the transformed sequence matches the given sequence\n    return transformed_sequence == given_sequence",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\",\"b\"])==False -> True (expected False)",
          "assert is_samepatterns([\"red\",\"green\",\"greenn\"], [\"a\",\"b\"])==False -> True (expected False)"
        ]
      },
      {
        "task_id": 75,
        "generated_code": "def find_tuples(tuples_list, k):\n    result = []\n    \n    for tup in tuples_list:\n        if all(element % k == 0 for element in tup):\n            result.append(tup)\n            \n    return result",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 77,
        "generated_code": "def is_Diff(number):\n        odd_sum = 0\n        even_sum = 0\n        position = 1\n        \n        while number > 0:\n            digit = number % 10\n            if position % 2 == 1:\n                odd_sum += digit\n            else:\n                even_sum += digit\n            number //= 10\n            position += 1\n        \n        diff = odd_sum - even_sum\n        return diff % 11 == 0\n    \n    # Test case\n    assert is_Diff(12345) == False",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "  File \"/tmp/tmpugh0ynk9.py\", line 19\n    assert is_Diff(12345) == False\n                                  ^\nIndentationError: unindent does not match any outer indentation level\n",
        "failed_tests": []
      },
      {
        "task_id": 79,
        "generated_code": "def word_len(word):\n    # Analysis:\n    # Get the length of the word\n    length = len(word)\n    \n    # Check if the length is odd\n    if length % 2 == 1:\n        return True\n    else:\n        return False\n\n# Test the function with the provided test case\nassert word_len(\"Hadoop\") == False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 80,
        "generated_code": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 82,
        "generated_code": "def volume_sphere(radius):\n    # Calculate the volume using the formula\n    volume = (4/3) * 3.14159 * (radius ** 3)\n    return volume",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpmatw_2ax.py\", line 7\n    _val = assert math.isclose(volume_sphere(10), 4188.790204786391, rel_tol=0.001)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 83,
        "generated_code": "def get_Char(s):\n    # <analysis>\n    # Sum up the ASCII values of all characters in the string\n    # Take the sum modulo 26 to ensure it falls within the range of lowercase letters\n    # Convert the result back to a character\n    # </analysis>\n\n    # Initialize the sum with 0\n    ascii_sum = 0\n    \n    # Iterate through each character in the string\n    for char in s:\n        # Add the ASCII value of the character to the sum\n        ascii_sum += ord(char)\n    \n    # Take the sum modulo 26\n    ascii_sum %= 26\n    \n    # Convert the result back to a character\n    return chr(ascii_sum + 97)  # Adding 97 shifts the result to the correct position in the alphabet\n\n# Test the function\nassert get_Char(\"abc\") == \"f\"",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmpq5imqxjj.py\", line 23, in <module>\n    assert get_Char(\"abc\") == \"f\"\n           ^^^^^^^^^^^^^^^^^^^^^^\nAssertionError\n",
        "failed_tests": []
      },
      {
        "task_id": 84,
        "generated_code": "def sequence(n):\n    if n <= 0:\n        return None\n    \n    # Initialize the dp array with base cases\n    dp = [None] * (n + 1)\n    dp[1], dp[2] = 1, 1\n    \n    # Fill the dp array iteratively\n    for i in range(3, n + 1):\n        dp[i] = dp[dp[i - 1]] + dp[i - dp[i - 1]]\n    \n    return dp[n]",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 85,
        "generated_code": "def surfacearea_sphere(r):\n    # Calculate the surface area using the formula 4 * pi * r^2\n    area = 4 * 3.14159 * r**2\n    return area",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmpgz34lxf_.py\", line 7\n    _val = assert math.isclose(surfacearea_sphere(10), 1256.6370614359173, rel_tol=0.001)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 86,
        "generated_code": "def centered_hexagonal_number(n):\n    # Calculate the nth centered hexagonal number using the formula\n    return 3 * n * (n - 1) + 1",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 87,
        "generated_code": "assert merge_dictionaries_three(\n    {\"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\"},\n    {\"G\": \"Green\", \"W\": \"White\"},\n    {\"O\": \"Orange\", \"W\": \"White\", \"B\": \"Black\"}\n) == {'B': 'Black', 'R': 'Red', 'P': 'Pink', 'G': 'Green', 'W': 'White', 'O': 'Orange'}",
        "execution_success": false,
        "reward": 0.1,
        "success": false,
        "error": "Traceback (most recent call last):\n  File \"/tmp/tmp57i7s0y_.py\", line 1, in <module>\n    assert merge_dictionaries_three(\n           ^^^^^^^^^^^^^^^^^^^^^^^^\nNameError: name 'merge_dictionaries_three' is not defined\n",
        "failed_tests": []
      },
      {
        "task_id": 88,
        "generated_code": "def freq_count(lst):\n    # Initialize an empty dictionary to store the frequencies\n    frequency_dict = {}\n    \n    # Iterate through the list\n    for item in lst:\n        # Check if the item is already in the dictionary\n        if item in frequency_dict:\n            # Increment the count of the item\n            frequency_dict[item] += 1\n        else:\n            # Add the item to the dictionary with a count of 1\n            frequency_dict[item] = 1\n    \n    # Return the dictionary of frequencies\n    return frequency_dict",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 89,
        "generated_code": "def closest_num(n):\n    if n >= 10:\n        return n - 1\n    else:\n        return n - 1 if n > 0 else 0",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 90,
        "generated_code": "def len_log(words):\n    max_length = 0  # Initialize the maximum length to 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n    return max_length",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 91,
        "generated_code": "def find_substring(string_list, substring):\n    \"\"\"\n    Checks if the given substring is present as a substring in any of the strings in the provided list.\n    \n    Parameters:\n    - string_list: List[str], a list of strings to search through.\n    - substring: str, the substring to search for within the strings of string_list.\n    \n    Returns:\n    - bool: True if the substring is found in any string of the list, False otherwise.\n    \"\"\"\n    for string in string_list:\n        if substring in string:\n            return True\n    return False",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 92,
        "generated_code": "def is_undulating(n):\n    # Convert the number to a string\n    n_str = str(n)\n    \n    # Calculate half the length of the number (or round down if odd)\n    mid = len(n_str) // 2\n    \n    # Check if the first half matches the second half reversed\n    return n_str[:mid] == n_str[-mid:] == n_str[mid:][::-1]",
        "execution_success": false,
        "reward": 0.3333333333333333,
        "success": false,
        "error": "",
        "failed_tests": [
          "assert is_undulating(1212121) == True -> False (expected True)",
          "assert is_undulating(121) == True -> False (expected True)"
        ]
      },
      {
        "task_id": 93,
        "generated_code": "def power(a, b):\n    \"\"\"\n    Calculate a raised to the power of b.\n    \n    Args:\n    a (int): The base.\n    b (int): The exponent.\n    \n    Returns:\n    int: The result of a raised to the power of b.\n    \"\"\"\n    return pow(a, b)",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 94,
        "generated_code": "def index_minimum(\n    # your implementation\n)",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmplhreql46.py\", line 3\n    )\n     ^\nSyntaxError: expected ':'\n",
        "failed_tests": []
      },
      {
        "task_id": 95,
        "generated_code": "def Find_Min_Length(\n    list_of_lists\n):\n    min_length = float('inf')\n    for sublist in list_of_lists:\n        length = len(sublist)\n        if length < min_length:\n            min_length = length\n    return min_length",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 96,
        "generated_code": "def divisor(n):\n    # Analysis\n    # We need to count how many numbers divide n without leaving a remainder\n    # We iterate through possible divisors up to the square root of n\n    \n    # Initialize the count of divisors\n    count = 0\n    \n    # Loop through possible divisors from 1 to sqrt(n)\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            # If i is a divisor, then n // i is also a divisor\n            count += 2  # Add both divisors\n            \n            # Check if the divisor is a perfect square\n            if i * i == n:\n                count -= 1  # Subtract one because we counted the square root twice\n    \n    return count",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 97,
        "generated_code": "def frequency_lists(lists):\n    # Analysis:\n    # Flatten the nested list and count frequencies\n\n    # Step 1: Flatten the list\n    flat_list = [item for sublist in lists for item in sublist]\n\n    # Step 2: Count frequencies\n    frequency_dict = {}\n    for item in flat_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n\n    return frequency_dict",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      },
      {
        "task_id": 98,
        "generated_code": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    length = len(numbers)\n    result = product / length\n    return result",
        "execution_success": false,
        "reward": 0.0,
        "success": false,
        "error": "  File \"/tmp/tmps7ky8u8l.py\", line 10\n    _val = assert math.isclose(multiply_num((8, 2, 3, -1, 7)), -67.2, rel_tol=0.001)\n           ^^^^^^\nSyntaxError: invalid syntax\n",
        "failed_tests": []
      },
      {
        "task_id": 99,
        "generated_code": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    \n    binary_digits = []\n    while n > 0:\n        binary_digits.append(str(n % 2))\n        n //= 2\n    \n    # Join the list into a string and reverse it\n    return ''.join(binary_digits[::-1])",
        "execution_success": true,
        "reward": 1.0,
        "success": true,
        "error": "",
        "failed_tests": []
      }
    ]
  },
  "comparison": {
    "grpo_accuracy": 0.6266666666666667,
    "srrl_accuracy": 0.6666666666666666,
    "accuracy_improvement": 6.382978723404243,
    "winner": "SRRL",
    "mcnemar_p": 0.36131042852617884,
    "discordant_srrl_only": 18,
    "discordant_grpo_only": 12,
    "grpo_ci": [
      0.5470043657114055,
      0.7000029457050124
    ],
    "srrl_ci": [
      0.5878960768592671,
      0.7371135434254932
    ],
    "recommended_sample_size": 2239
  }
}